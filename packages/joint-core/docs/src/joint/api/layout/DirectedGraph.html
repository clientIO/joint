<p>Automatic layout of directed graphs. This plugin uses the open-source (MIT license) <a href="https://github.com/cpettitt/dagre">Dagre</a> library internally.</p>

<h3 id="layout.DirectedGraph.installation">Installation</h3>

<p>Add the <code>@joint/layout-directed-graph</code> package as a dependency of your project (for example via <code>yarn</code>):</p>

<pre><code>yarn add @joint/layout-directed-graph
yarn install</code></pre>

<p>You can then import the package into your code:</p>

<pre><code>import { DirectedGraph } from '@joint/layout-directed-graph';</code></pre>

<h3 id="layout.DirectedGraph.usage">Usage</h3>

<p>The <code>DirectedGraph</code> package exposes the <code>layout(graphOrCells, opt)</code> function. The first parameter <code>graphOrCells</code> is a <code>joint.dia.Graph</code> or an array of <code>joint.dia.Cells</code> that we want to lay out. The second parameter <code>opt</code> is an object that contains various options for configuring the layout.</p>

<pre><code>import { DirectedGraph } from '@joint/layout-directed-graph';
var graphBBox = DirectedGraph.layout(graph, {
    nodeSep: 50,
    edgeSep: 80,
    rankDir: "TB"
});
console.log('x:', graphBBox.x, 'y:', graphBBox.y)
console.log('width:', graphBBox.width, 'height:', graphBBox.height);</code></pre>

<p>A blog post explaining the usage of the <code>layout(graphOrCells, opt)</code> function in more detail can be found <a href="http://www.daviddurman.com/automatic-graph-layout-with-jointjs-and-dagre.html">here</a>.</p>

<h3 id="layout.DirectedGraph.configuration">Configuration</h3>

<p>The following table lists options that you can pass to the <code>layout(graphOrCells, opt)</code> function:</p>

<table>
    <tr><th>nodeSep</th>
        <td>a number of pixels representing the separation between adjacent nodes in the same rank</td>
    </tr>
    <tr><th>edgeSep</th>
        <td>a number of pixels representing the separation between adjacent edges in the same rank</td>
    </tr>
    <tr><th>rankSep</th>
        <td>a number of pixels representing the separation between ranks</td>
    </tr>
    <tr><th>rankDir</th>
        <td>direction of the layout (one of <code>"TB"</code> (top-to-bottom) / <code>"BT"</code> (bottom-to-top) / <code>"LR"</code> (left-to-right) / <code>"RL"</code> (right-to-left))</td>
    </tr>
    <tr><th>marginX</th>
        <td>number of pixels to use as a margin around the left and right of the graph.</td>
    </tr>
    <tr><th>marginY</th>
        <td>number of pixels to use as a margin around the top and bottom of the graph.</td>
    </tr>
    <tr><th>ranker</th>
        <td>Type of algorithm to assign a rank to each node in the input graph. Possible values: <code>'network-simplex'</code> (default), <code>'tight-tree'</code> or <code>'longest-path'</code>.</td>
    </tr>
    <tr><th>resizeClusters</th>
        <td>set to <code>false</code> if you don't want parent elements to stretch in order to fit all their embedded children. Default is <code>true</code>.</td>
    </tr>
    <tr><th>clusterPadding</th>
        <td>A gap between the parent element and the boundary of its embedded children. It could be a number or an object e.g. <code>{ left: 10, right: 10, top: 30, bottom: 10 }</code>. It defaults to <code>10</code>.</td>
    </tr>
    <tr><th>setPosition(element, position)</th>
        <td>
            a function that will be used to set the position of elements at the end of the layout. This is useful
            if you don't want to use the default <code>element.set('position', position)</code> but want to set the position in an animated fashion via <a href="#dia.Element.prototype.transition">transitions</a>.
        </td>
    </tr>
    <tr><th>setVertices(link, vertices)</th>
        <td>
            If set to <code>true</code> the layout will adjust the links by setting their vertices. It defaults to <code>false</code>. If the option is defined as a function it will be used to set the vertices of links at the end of the layout. This is useful
            if you don't want to use the default <code>link.set('vertices', vertices)</code> but want to set the vertices in an animated fashion via <a href="#dia.Link.prototype.transition">transitions</a>.
        </td>
    </tr>
    <tr><th>setLabels(link, labelPosition, points)</th>
        <td>
            If set to <code>true</code> the layout will adjust the labels by setting their position. It defaults to <code>false</code>. If the option is defined as a function it will be used to set the labels of links at the end of the layout.
            <br/><br/>
            <em><b>Note:</b> Only the first label (<code>link.label(0);</code>) is positioned by the layout.</em>
        </td>
    </tr>
    <tr><th>exportElement(element)</th>
        <td>
            Convert element attributes into dagre <a target="_blank" href="https://github.com/dagrejs/dagre/wiki#configuring-the-layout">node</a> attributes.
            By default, it returns the <a href="#layout.DirectedGraph.cellAttributes">element attributes</a> below.
        </td>
    </tr>
    <tr><th>exportLink(link)</th>
        <td>
            Convert link attributes into dagre <a target="_blank" href="https://github.com/dagrejs/dagre/wiki#configuring-the-layout">edge</a> attributes.
            By default, it returns the <a href="#layout.DirectedGraph.cellAttributes">link attributes</a> below.
        </td>
    </tr>
</table>

<p>Additionally, the layout engine takes into account some properties on elements/links to fine tune the layout further. These are:</p>

<table id="layout.DirectedGraph.cellAttributes">
    <tr>
        <th>size</th>
        <td>element</td>
        <td>An object with `width` and `height` properties representing the size of the element.</td>
    </tr>
    <tr>
        <th>minLen</th>
        <td>link</td>
        <td>The number of ranks to keep between the source and target of the link.</td>
    </tr>
    <tr>
        <th>weight</th>
        <td>link</td>
        <td>The weight to assign edges. Higher weight edges are generally made shorter and straighter than lower weight edges.</td>
    </tr>
    <tr>
        <th>labelPosition</th>
        <td>link</td>
        <td>Where to place the label relative to the edge. <code>'l'</code> = left, <code>'c'</code> = center (default), <code>'r'</code> = right.
        </td>
    </tr>
    <tr>
        <th>labelOffset</th>
        <td>link</td>
        <td>How many pixels to move the label away from the edge. Applies only when <code>labelPosition</code> is left or right.</td>
    </tr>
    <tr>
        <th>labelSize</th>
        <td>link</td>
        <td>The width and height of the edge label in pixels. e.g. <code>{ width: 100, height: 50 }</code></td>
    </tr>
</table>

<p>The <code>layout(graphOrCells, opt)</code> function returns a bounding box (<code>g.Rect</code>) of the resulting graph.</p>

<h3 id="layout.DirectedGraph.api">API</h3>

<p>The <code>DirectedGraph</code> package also provides two functions that make it easy to convert graphs to and from the <a href="https://github.com/dagrejs/graphlib">Graphlib</a> graph format. This allows you to use the wealth of <a href="https://github.com/dagrejs/graphlib/wiki/API-Reference">graph algorithms</a> provided by the Graphlib library.</p>

<p>In order to use Graphlib, you need to add the package as an additional dependency of your project (for example via <code>yarn</code>):</p>

<pre><code>yarn add @dagrejs/graphlib
yarn install</code></pre>

<p>You can then import the package into your code:</p>

<pre><code>import * as graphlib from '@dagrejs/graphlib';</code></pre>

<table>
    <tr><th>toGraphLib(graph, opt)</th>
        <td>Convert the provided JointJS <code>joint.dia.Graph</code> object to a Graphlib graph object.
            <pre><code>import { dia, shapes } from '@joint/core';
import { DirectedGraph } from '@joint/layout-directed-graph';
import * as graphlib from '@dagrejs/graphlib';

const graph = new dia.Graph({}, { cellNamespace: shapes });
// ... populate the graph with elements connected with links

// Get a Graphlib representation of the graph:
const glGraph = DirectedGraph.toGraphLib(graph);

// Use Graphlib algorithms:
graphlib.alg.isAcyclic(glGraph); // true if the graph is acyclic</code></pre>
        </td>
    </tr>
    <tr><th>fromGraphLib(glGraph, opt)</th>
        <td>Convert the provided Graphlib graph object to a JointJS <code>joint.dia.Graph</code> object.
            <br/><br/>
            Custom <code>opt.importNode</code> and <code>opt.importEdge</code> callbacks need to be provided in order for this method to work as expected - to return a JointJS Graph matching the structure of the provided Graphlib graph (<code>glGraph</code>). The callbacks are provided with the following attributes:
            <ul>
                <li><code>nodeId</code> / <code>edgeObj</code> - a <a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#node-and-edge-representation">Graphlib item ID</a>,</li>
                <li><code>glGraph</code> - the original Graphlib graph object,</li>
                <li><code>graph</code> - the JointJS Graph object to be populated (a newly created <code>joint.dia.Graph</code> by default),</li>
                <li><code>opt</code> - the options object provided to <code>fromGraphLib()</code>.</li>
            </ul>
            You can implement your own logic inside the two callbacks to support your use case.
            <br/><br/>
            The example below illustrates how Graphlib node/edge labels can be used to store additional information for each item. These labels are accessed in the callbacks as <code>nodeData</code> / <code>edgeData</code>, and the information within is used to specify the position, size, and label text of the Element / Link being created. (Note: In Graphlib, edge source id / edge target id are specified via <code>nodeId</code> of the respective node; we need to set the <code>id</code> of generated Elements as <code>nodeId</code> so that the generated Links can connect the generated Elements.) The callbacks work by adding the generated Element / Link to the <code>graph</code> in the end (e.g. via the <code>graph.addCell()</code> function):
            <pre><code>import { shapes } from '@joint/core';
import { DirectedGraph } from '@joint/layout-directed-graph';
import * as graphlib from 'graphlib';

// Create a graph in Graphlib:
const glGraph = new graphlib.Graph();
glGraph.setNode(1, { x: 50, y: 50, width: 100, height: 50, label: 'A' });
glGraph.setNode(2, { x: 50, y: 150, width: 100, height: 50, label: 'B' });
glGraph.setNode(3, { x: 50, y: 250, width: 100, height: 50, label: 'C' });
glGraph.setEdge(1, 2, { label: 'Hello' });
glGraph.setEdge(2, 3, { label: 'World!' });

// Get a JointJS representation of the Graphlib graph:
const graph = DirectedGraph.fromGraphLib(glGraph, {
    importNode: (nodeId, glGraph, graph, opt) => {
        const nodeData = glGraph.node(nodeId);
        const element = new shapes.standard.Rectangle({
            id: nodeId,
            position: { x: nodeData.x, y: nodeData.y },
            size: { width: nodeData.width, height: nodeData.height },
            attrs: { label: { text: nodeData.label }}
        });
        graph.addCell(element);
    },
    importEdge: (edgeObj, glGraph, graph, opt) => {
        const edgeData = glGraph.edge(edgeObj);
        const link =  new shapes.standard.Link({
            source: { id: edgeObj.v },
            target: { id: edgeObj.w },
            labels: [{ attrs: { text: { text: edgeData.label }}}]
        });
        graph.addCell(link);
    }
});</code></pre>
        </td>
    </tr>
</table>
