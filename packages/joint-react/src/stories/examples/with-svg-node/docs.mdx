import { Meta, Story, Canvas, Controls, Markdown } from '@storybook/blocks';
import * as Stories from './story';
import Code from './code?raw';
import {getAPIPropsLink} from '../../utils/get-api-documentation-link'


<Meta of={Stories} />

# SVG Node Rendering

This example demonstrates how to render custom SVG elements as nodes in your diagram. By default, JointJS renders nodes using SVG, and you can customize the appearance by providing a `renderElement` function to the Paper component.

## Overview

SVG nodes are the foundation of JointJS diagrams. This example shows how to:
- Create custom SVG shapes and elements
- Use the `renderElement` prop to define node appearance
- Access element properties (width, height, position) in your render function
- Combine multiple SVG elements to create complex node designs

## Demo

<Canvas of={Stories.Default} />

## Implementation

<Markdown>
{`\`\`\`tsx
${Code}
\`\`\``}
</Markdown>

## Key Concepts

### renderElement Function

The {getAPIPropsLink('Paper', 'renderElement')} prop receives element properties and returns SVG content:

```tsx
function renderElement({ width, height, x, y, id, ...otherProps }) {
  return (
    <g>
      <rect width={width} height={height} fill="blue" />
      <text x={width/2} y={height/2}>Node</text>
    </g>
  );
}
```

### Element Properties

The render function receives:
- **width/height**: Element dimensions
- **x/y**: Element position (usually handled by Paper)
- **id**: Unique element identifier
- **attrs**: Custom attributes from element data
- Any other properties from your element data

## Best Practices

1. **Use semantic SVG**: Use appropriate SVG elements (rect, circle, path, etc.)
2. **Leverage element props**: Use width/height from props, not hardcoded values
3. **Group elements**: Use `<g>` to group related SVG elements
4. **Performance**: Keep SVG structure simple for better rendering performance
5. **Reusability**: Extract common SVG patterns into reusable components









