import { Meta, Canvas, Markdown } from '@storybook/addon-docs/blocks';
import * as Stories from './story';
import CodeSVG from './code-svg?raw';
import CodeHTML from './code-html?raw';
import CodeHTMLRenderer from './code-html-renderer?raw';
import CodeControlledMode from './code-controlled-mode?raw';
import CodeControlledModeRedux from './code-controlled-mode-redux?raw';
import CodeControlledModeZustand from './code-controlled-mode-zustand?raw';
import CodeControlledModeJotai from './code-controlled-mode-jotai?raw';
import CodeControlledModePeerJS from './code-controlled-mode-peerjs?raw';
import { getAPIDocumentationLink, getAPIPropsLink } from '../../utils/get-api-documentation-link';

<Meta of={Stories} />

# Get started with @joint/react

Welcome! This guide will help you get started with the new `@joint/react` library, which brings the power of [JointJS](https://www.jointjs.com/) to React. We'll walk through the core concepts step by step, with live examples and code blocks.

---

## 1. What is @joint/react?

- **@joint/react** is a React-first API for building interactive diagrams, powered by [JointJS](https://www.jointjs.com/).
- **JointJS** is a diagramming library for creating flowcharts, BPMN, ER diagrams, and more.
- **@joint/react** wraps JointJS concepts in idiomatic React components and hooks, making it intuitive for React developers.

---

## 2. Core concepts

- **Element (Node):** A visual item in your diagram (e.g., a rectangle, circle, or custom shape).
- **Link (Edge):** A connection between two elements.
- **Graph:** The data model holding all elements and links.
- **GraphProvider:** React context provider for managing the graph state.
- **Paper:** The main rendering component for nodes and links.
- **Ports:** Named connection points on elements for precise linking.
- **MeasuredNode:** Utility for auto-sizing nodes based on their content.

---

## 3. Creating elements and links

### a. Elements (Nodes)

Elements are plain objects with geometry properties (`x`, `y`, `width`, `height`). They are stored as Records keyed by their ID.

```tsx
const elements = {
  '1': { label: 'Node 1', x: 100, y: 0, width: 100, height: 25 },
  '2': { label: 'Node 2', x: 100, y: 200, width: 100, height: 25 },
};
```

### b. Links (Edges)

Links are plain objects with `source` and `target` properties. They are stored as Records keyed by their ID.

```tsx
const links = {
  'l1': { source: '1', target: '2' },
};
```

---

## 4. Setting up the GraphProvider context

Wrap your app with the `GraphProvider` component to provide the graph context to all child components.

```tsx
import { GraphProvider } from '@joint/react';

<GraphProvider elements={elements} links={links}>
  {/* Add Paper or other components here */}
</GraphProvider>
```

For simpler use cases, you can render a standalone view without a surrounding provider:

```tsx
<Paper elements={elements} links={links} />
```

---

## 5. Rendering the diagram

The `Paper` component renders your graph. It provides props for customizing the rendering and handling interactions.

```tsx
function RenderNode({ width, height, label }) {
  return <rect width={width} height={height} fill="lightblue"><title>{label}</title></rect>;
}

<Paper
  width="100%"
  height={300}
  renderElement={RenderNode}
  onLinkMouseEnter={({ linkView }) => {
    linkView.highlight();
  }}
/>
```

---

## 6. Using HTML in nodes

If you need full HTML support, enable the experimental `useHTMLOverlay` prop to render real HTML outside the SVG. Otherwise, use `<foreignObject>`.

```tsx
<Paper
  useHTMLOverlay
  renderElement={({ label }) => (
    <div style={{
      background: 'lightgray',
      padding: '10px',
      borderRadius: '5px',
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
    }}>
      {label}
    </div>
  )}
/>
```

---

## 7. Advanced features

### a. Ports

Ports allow you to define named connection points on elements for links.

```tsx
function RenderNodeWithPorts({ label, width, height }) {
  return (
    <>
      <rect width={width} height={height} fill="lightblue">
        <title>{label}</title>
      </rect>
      <Port.Group id="ports" position="top">
        <Port id="in">
          <circle r={5} fill="red" />
        </Port>
        <Port id="out">
          <circle r={5} fill="green" />
        </Port>
      </Port.Group>
    </>
  );
}
```

### b. Customizing behavior

Customize link behavior with props like `defaultRouter` and `defaultConnector`:

```tsx
<Paper
  defaultRouter={{ name: 'manhattan' }}
  defaultConnector={{ name: 'smooth' }}
/>
```

---

## 8. Live examples

### SVG Node Example

<Canvas of={Stories.SVG} />
<Markdown>
{`\`\`\`tsx
${CodeSVG}
\`\`\``}
</Markdown>

### HTML Node Example

<Canvas of={Stories.HTML} />
<Markdown>
{`\`\`\`tsx
${CodeHTML}
\`\`\``}
</Markdown>

### HTML Overlay Example

<Canvas of={Stories.HTMLRenderer} />
<Markdown>
{`\`\`\`tsx
${CodeHTMLRenderer}
\`\`\``}
</Markdown>

### Controlled Mode with useState

This example demonstrates how to use `@joint/react` in **React-controlled mode** with React's `useState` hook. In controlled mode, React state is the single source of truth for the graph, and all changes flow through React state.

<Canvas of={Stories.ControlledMode} />
<Markdown>
{`\`\`\`tsx
${CodeControlledMode}
\`\`\``}
</Markdown>

#### How It Works:

1. **State Management**: Use `useState` to manage elements and links as Records:
   ```tsx
   const [elements, setElements] = useState<Record<string, GraphElement>>(defaultElements);
   const [links, setLinks] = useState<Record<string, GraphLink>>(defaultLinks);
   ```

2. **Controlled Mode**: Pass state and change handlers to `GraphProvider`:
   ```tsx
   <GraphProvider
     elements={elements}
     links={links}
     onElementsChange={setElements}
     onLinksChange={setLinks}
   >
   ```

3. **Bidirectional Sync**: 
   - **React ‚Üí Graph**: When you update React state, GraphProvider syncs to JointJS graph
   - **Graph ‚Üí React**: When user interacts (drags nodes), GraphProvider calls `onElementsChange`/`onLinksChange` to update React state

4. **State Flow**: User drags node ‚Üí GraphProvider detects change ‚Üí Calls `onElementsChange` ‚Üí Updates React state ‚Üí Component re-renders ‚Üí GraphProvider syncs new state to graph

#### When to Use:
- ‚úÖ You need full control over graph state
- ‚úÖ You want to implement undo/redo (save state history)
- ‚úÖ You need to persist state (localStorage, server, etc.)
- ‚úÖ You're integrating with other React state management

---

### External Store Integration: Redux

This example demonstrates how to integrate `@joint/react` with **Redux** using the `ExternalGraphStore` interface. Redux provides centralized state management with time-travel debugging via Redux DevTools.

<Canvas of={Stories.ControlledModeRedux} />
<Markdown>
{`\`\`\`tsx
${CodeControlledModeRedux}
\`\`\``}
</Markdown>

#### How It Works:

1. **Redux Store**: Create a Redux store with a slice for graph state (elements and links)
2. **Undo/Redo**: Use `redux-undo` library to automatically handle undo/redo functionality
3. **Adapter Hook**: Use `useReduxAdapter()` hook to convert Redux store to `ExternalGraphStore`
4. **GraphProvider**: Pass the `externalStore` prop to `GraphProvider` instead of `elements`/`links`/`onElementsChange`

#### Key Benefits:
- ‚úÖ **Centralized State**: All graph state lives in Redux store
- ‚úÖ **Time-Travel Debugging**: Redux DevTools for inspecting and replaying state changes
- ‚úÖ **Undo/Redo**: Easy undo/redo with `redux-undo` library
- ‚úÖ **Predictable Updates**: All changes go through Redux actions
- ‚úÖ **Integration**: Easy to integrate with other Redux features

#### The Adapter Pattern:
The `useReduxAdapter()` hook creates an adapter that implements the `ExternalGraphStore` interface:
- `getSnapshot()`: Reads current state from Redux
- `subscribe()`: Subscribes to Redux store changes
- `setState()`: Dispatches Redux actions to update state

**Important**: When using `externalStore`, GraphProvider captures **ALL** state changes, including position changes from dragging nodes. This is the key advantage over React-controlled mode!

---

### External Store Integration: Zustand

This example demonstrates how to integrate `@joint/react` with **Zustand**, a lightweight state management library. Zustand has a simple API with minimal boilerplate.

<Canvas of={Stories.ControlledModeZustand} />
<Markdown>
{`\`\`\`tsx
${CodeControlledModeZustand}
\`\`\``}
</Markdown>

#### How It Works:

1. **Zustand Store**: Create a store with `create()` containing state and actions
2. **Adapter Hook**: Use `useZustandAdapter()` hook to convert Zustand store to `ExternalGraphStore`
3. **GraphProvider**: Pass the `externalStore` prop to `GraphProvider`
4. **Actions**: Use Zustand hooks to access actions in components

#### Key Benefits:
- ‚úÖ **Simple API**: Minimal boilerplate, no actions/reducers needed
- ‚úÖ **TypeScript Support**: Full type safety out of the box
- ‚úÖ **Lightweight**: Small bundle size
- ‚úÖ **Easy Hooks**: Simple hooks for accessing state and actions
- ‚úÖ **All Changes Synced**: Position changes from dragging are automatically captured

---

### External Store Integration: Jotai

This example demonstrates how to integrate `@joint/react` with **Jotai**, an atomic state management library. Jotai uses atoms as building blocks for state.

<Canvas of={Stories.ControlledModeJotai} />
<Markdown>
{`\`\`\`tsx
${CodeControlledModeJotai}
\`\`\``}
</Markdown>

#### How It Works:

1. **Atoms**: Create atoms for elements and links using `atom()`
2. **Store**: Create a Jotai store to manage atom subscriptions
3. **Adapter Hook**: Use `useJotaiAdapter()` hook to convert atoms to `ExternalGraphStore`
4. **GraphProvider**: Pass the `externalStore` prop to `GraphProvider`
5. **Hooks**: Use `useAtom()` hooks to access and update atoms in components

#### Key Benefits:
- ‚úÖ **Atomic State**: Split state into small, independent pieces
- ‚úÖ **No Providers**: Atoms work globally without providers
- ‚úÖ **TypeScript Support**: Full type safety
- ‚úÖ **Simple API**: Just atoms and hooks
- ‚úÖ **All Changes Synced**: Position changes from dragging are automatically captured

---

### External Store Integration: PeerJS (Collaborative Mode)

This example demonstrates how to share graph state between multiple peers using **PeerJS** for real-time collaboration. Multiple users can connect and see each other's changes in real-time.

<Canvas of={Stories.ControlledModePeerJS} />
<Markdown>
{`\`\`\`tsx
${CodeControlledModePeerJS}
\`\`\``}
</Markdown>

#### How It Works:

1. **PeerJS Store**: Create a custom store that implements `ExternalGraphStore` and syncs via PeerJS
2. **Peer Connection**: Each peer gets a unique ID and can connect to other peers
3. **State Sync**: When one peer updates the graph, changes are sent to all connected peers via WebRTC
4. **Bidirectional**: Changes sync in both directions - all peers see each other's updates

#### Key Features:
- ‚úÖ **Real-Time Collaboration**: Multiple users can edit the same graph simultaneously
- ‚úÖ **Peer-to-Peer**: Direct browser-to-browser communication (no server needed except signaling)
- ‚úÖ **All Changes Synced**: Position changes, additions, removals - everything syncs automatically
- ‚úÖ **Copy ID Button**: Easy way to copy your peer ID to share with others
- ‚úÖ **Connection Status**: Visual feedback showing connection state

#### Usage:
1. Open this page in two browser windows/tabs
2. Each window gets a unique peer ID
3. Copy the ID from one window
4. Paste it into the "Enter peer ID to connect" field in the other window
5. Click "Connect"
6. Both peers are now connected and will see each other's changes in real-time!

---

## Understanding State Management Modes

`@joint/react` supports three modes of operation:

### 1. Uncontrolled Mode (Default)
The graph manages its own state internally. Use this for simple, read-only diagrams.

```tsx
<GraphProvider elements={initialElements} links={initialLinks}>
  <Paper />
</GraphProvider>
```

### 2. React-Controlled Mode
React state controls the graph. Use `onElementsChange` and `onLinksChange` props.

```tsx
const [elements, setElements] = useState(initialElements);
const [links, setLinks] = useState(initialLinks);

<GraphProvider
  elements={elements}
  links={links}
  onElementsChange={setElements}
  onLinksChange={setLinks}
>
  <Paper />
</GraphProvider>
```

**Note**: This mode captures changes from user interactions, but you need to ensure all updates go through React state.

### 3. External Store Mode (Recommended for Complex Apps)
An external store (Redux, Zustand, Jotai, etc.) controls the graph. Use the `externalStore` prop.

```tsx
const store = createExternalStore(); // Redux, Zustand, Jotai, etc.

<GraphProvider externalStore={store}>
  <Paper />
</GraphProvider>
```

**Why External Store Mode?**
- ‚úÖ **Captures ALL changes**: Position changes from dragging are automatically captured
- ‚úÖ **Better integration**: Works seamlessly with your existing state management
- ‚úÖ **More control**: Full control over when and how state updates
- ‚úÖ **Easier debugging**: Use your state management's dev tools

#### The ExternalGraphStore Interface

All external stores must implement this interface:

```tsx
interface ExternalGraphStore {
  getSnapshot(): GraphStoreSnapshot;  // Returns current state
  subscribe(listener: () => void): () => void;  // Subscribe to changes
  setState(updater: Update<GraphStoreSnapshot>): void;  // Update state
}
```

This interface is compatible with:
- Redux (via adapter)
- Zustand (via adapter)
- Jotai (via adapter)
- PeerJS (custom implementation)
- Any other store that implements these three methods

---

## 9. Key Terms and Concepts

### Core Components
- **GraphProvider:** React context provider for managing graph state. Supports three modes: uncontrolled, React-controlled, and external-store-controlled.
- **Paper:** The main rendering component that displays the graph visually. Can be used multiple times in one GraphProvider for features like minimaps.
- **Element (Node):** A visual item in your diagram (e.g., a rectangle, circle, or custom shape).
- **Link (Edge):** A connection between two elements.

### State Management
- **Uncontrolled Mode:** Graph manages its own state internally. Best for simple, read-only diagrams.
- **React-Controlled Mode:** React state controls the graph via `onElementsChange`/`onLinksChange` props. Good for basic state management needs.
- **External Store Mode:** External state management (Redux, Zustand, Jotai, etc.) controls the graph via `externalStore` prop. **Recommended for complex apps** as it captures ALL changes including position updates.

### Advanced Features
- **Port:** Named connection point on an element for precise linking.
- **MeasuredNode:** Utility component that auto-measures and updates node size based on content.
- **useHTMLOverlay:** Renders HTML nodes outside SVG for full HTML support.
- **ExternalGraphStore:** Interface that allows any state management library to work with GraphProvider. Requires `getSnapshot()`, `subscribe()`, and `setState()` methods.

---

## 10. Choosing the Right Mode

### Use Uncontrolled Mode When:
- ‚úÖ Simple, read-only diagrams
- ‚úÖ No need to track state changes
- ‚úÖ Performance is critical (fastest mode)

### Use React-Controlled Mode When:
- ‚úÖ You need basic state control
- ‚úÖ You want to implement simple undo/redo
- ‚úÖ You need to persist state to localStorage
- ‚ö†Ô∏è **Note**: Make sure all updates go through React state setters

### Use External Store Mode When:
- ‚úÖ **You need to capture ALL changes** (including position changes from dragging)
- ‚úÖ You're already using Redux, Zustand, Jotai, or another state management library
- ‚úÖ You need advanced features (undo/redo, persistence, collaboration)
- ‚úÖ You want better integration with your app's state management
- ‚úÖ You need time-travel debugging (Redux DevTools, etc.)

**Recommendation**: For production apps, prefer External Store Mode as it provides the most reliable state synchronization.

---

## 11. More Resources

- [@joint/react API Reference](https://github.com/clientIO/joint-plus/tree/main/packages/joint-react)
- [JointJS Documentation](https://docs.jointjs.com/)

## 11. Multiple views in a single GraphProvider

You can render multiple `Paper` instances inside one `GraphProvider` to create features like a minimap, a read-only overview, or separate layers. When using multiple views in development, assign a unique `id` to each view.

```tsx
import { GraphProvider } from '@joint/react';

const elements = {
  '1': { label: 'A', x: 50, y: 50, width: 80, height: 40 },
  '2': { label: 'B', x: 250, y: 180, width: 80, height: 40 },
};

export function MultiViews() {
  return (
    <GraphProvider elements={elements}>
      {/* Main interactive canvas */}
      <Paper id="main" width={800} height={500} />

      {/* Read-only overview/minimap */}
      <Paper
        id="overview"
        width={200}
        height={120}
        interactive={false}
        scale={0.25}
        style={{ border: '1px solid #ddd' }}
      />
    </GraphProvider>
  );
}
```

Tips:
- Give each view a stable `id`.
- Use `interactive={false}` and a smaller `scale` for an overview/minimap.
- Share the same `elements`/`links` via the parent `GraphProvider`.

---


## 12. Accessing a view via hook or ref

There are two ergonomic ways to reach the underlying Paper/Graph of a view for imperative needs.

### a. Via hook (by id)

Use an internal hook to subscribe to a named view from anywhere under `GraphProvider`. This is handy for utilities colocated outside the view subtree.

```tsx
import { useEffect } from 'react';
// import { useGraphView } from '@joint/react' // ensure it is exported in your setup

function FitToContent() {
  const view = useGraphView('main');
  useEffect(() => {
    view?.paper.fitToContent({ padding: 20 });
  }, [view]);
  return null;
}

export function WithHook() {
  return (
    <GraphProvider elements={elements}>
      <Paper id="main" />
      <FitToContent />
    </GraphProvider>
  );
}
```

### b. Via ref (accessing paperCtx)

Any component that accepts a `ref` (such as `Paper` or `GraphProvider`) exposes its instance/context via the ref. For `Paper`, the instance (including the underlying JointJS Paper) can be accessed via the `paperCtx` property on the ref object.

```tsx
import { useEffect, useRef } from 'react';
import type { PaperContext } from '@joint/react';

export function WithRef() {
  const paperRef = useRef<PaperContext | null>(null);
  useEffect(() => {
    // Access the Paper context (paperCtx) from the ref
    const paperCtx = paperRef.current?.paperCtx;
    // You can also access the JointJS Paper instance directly
    const paper = paperCtx?.paper;
    paper?.scale(2, 2);
  }, []);

  return (
    <GraphProvider elements={elements}>
      <Paper id="zoomed" ref={paperRef} />
    </GraphProvider>
  );
}
```

---

## 13. Small real‚Äëworld patterns

### a. Canvas + Minimap

```tsx
function GraphWithMinimap() {
  return (
    <GraphProvider elements={elements} links={links}>
      <Paper id="main" width="100%" height={400} />
      <div style={{ position: 'absolute', right: 16, bottom: 16 }}>
        <Paper id="mini" width={180} height={120} interactive={false} scale={0.2} />
      </div>
    </GraphProvider>
  );
}
```

### b. Read‚Äëonly preview next to an editor

```tsx
function EditorWithPreview() {
  return (
    <div style={{ display: 'grid', gridTemplateColumns: '1fr 320px', gap: 16 }}>
      <GraphProvider elements={elements} links={links}>
        <Paper id="editable" />
      </GraphProvider>
      <GraphProvider elements={elements} links={links}>
        <Paper id="preview" interactive={false} />
      </GraphProvider>
    </div>
  );
}
```

### c. HTML nodes with overlay

```tsx
const renderElement = ({ label }) => (
  <div style={{ padding: 8, borderRadius: 8, background: 'white', boxShadow: '0 1px 3px rgba(0,0,0,.15)' }}>
    {label}
  </div>
);

function HtmlNodes() {
  return (
    <GraphProvider elements={elements}>
      <Paper useHTMLOverlay renderElement={renderElement} />
    </GraphProvider>
  );
}
```


---

Happy diagramming! üöÄ

---