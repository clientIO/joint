<!DOCTYPE html>
<html>
    <head>

        <link rel="canonical" href="http://www.jointjs.com/" />
        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />
        <meta name="keywords" content="JointJS, JavaScript, diagrams, diagramming library, UML, charts" />

        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prismjs/themes/prism.css">


        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>


        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <link rel="stylesheet" href="css/ports.css">
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>

    </head>
    <body class="language-javascript tutorial-page">


        <div id="ports" class="tutorial">

            <!-- <p>
                e2e testing checklist.
            </p>

            <ul>
                <li>playwright/cypress</li>
                <li>drag components</li>
                <li>link components</li>
                <li>edit properties of component in inspector</li>
                <li>drag & drop</li>
                <li>output diagram reference image/comparison</li>
                <li>visual regression</li>
                <li>verify app is setup</li>
                <li>touch events</li>
                <li>experimental role selectors</li>
            </ul> -->

            <h2>E2E Testing with Playwright</h2>

            <p>
                E2E testing is an integral part of ensuring your application behaves as expected. As we often get asked how to perform
                end-to-end testing for JointJS applications, in the following tutorial, we will cover some core concepts, and hopefully
                give you some inspiration for whatever testing technology you choose to use.
            </p>

            <p>
                To start with, let's introduce <a href="https://playwright.dev/" target="_blank">Playwright</a>, the testing framework of
                our choice. Playwright is a microsoft project, that supports all modern rendering engines, Chromium, Webkit, and Firefox. 
                It also has cross-language support, so if your application uses TypeScript, Playwright has you covered. Playwright provides 
                you with a lot of functionality right out of the box, and a very nice API to test your user interface.
            </p>

            <p>
                Playwright can be used as a library, but we will be using it as part of the Playwright Test test runner. It was created
                specifically to accommodate the needs of end-to-end testing.
            </p>

            <h3 id="installation">
                Installation
            </h3>

            <p>
                Playwright requires Node.js version 12 or above. Run <code>node -v</code> from the command line to make sure you have a 
                compatible version of Node.js. If you have a suitable version, we are ready begin. As we know our application and tests
                directories will live in the root folder of our project, that's where we will install the dependency and default browsers.
                This tutorial uses version <code>"@playwright/test": "1.21.1"</code>, and to install, we run the following commands from 
                the terminal.
            </p>

    <pre><code>npm i -D @playwright/test@1.21.1
// install supported browsers
npx playwright install
</code></pre>

            <p>
                As we want to enjoy all the features Playwright has to offer, we will also create a configuration file 
                <code>playwright.config.js</code> in our project root. The following config will run every test in Chromium, Firefox, and 
                WebKit by creating a "project" for each browser configuration.
            </p>

    <pre><code>const { devices } = require('@playwright/test');

const config = {
    projects: [
        {
            name: 'chromium',
            use: { ...devices['Desktop Chrome'] },
        },
        {
            name: 'firefox',
            use: { ...devices['Desktop Firefox'] },
        },
        {
            name: 'webkit',
            use: { ...devices['Desktop Safari'] },
        },
    ],
};

module.exports = config;
        
</code></pre>

        <p>
            Now that our minimal testing setup is complete, we are ready to write our first test. Our test files
            will be placed in the <code>tests</code> directory located in the project root, and each test spec will 
            have the suffix <code>.spec.js</code>. Let's create our first spec file, and name it 
            <code>example.spec.js</code>.
        </p>

        <h3 id="basic-testing">
            Basic Testing
        </h3>

        <p>
            Our first test simply visits a specific page. As we are working locally, our url is our
            localhost, but of course you can insert your own url in this test example. Playwright Test provides a 
            <code>test</code> function to declare tests, and an <code>expect</code> function to write assertions.
            The <code>page</code> argument is a test fixture, it provides methods which allow you to interact with 
            the browser.
        </p>

    <pre><code>const { test, expect } = require('@playwright/test');

test('Visit Page', async ({ page }) => {
  await page.goto('http://localhost:3000/');
  const pageTitle = await page.title();
  expect(pageTitle).toBe('JointJS App');
});
</code></pre>

        <p>
            When we are satisfied with our first test, and have checked our application is up and running (in our case,
            on <i>localhost:3000</i>), we simply run <code>npx playwright test</code> from our project root. The test 
            will run in headless browsers, and if successful, you should see something similar to the following output:
        </p>

<pre><code>Running 3 tests using 2 workers
    
✓  [firefox] › tests/example.spec.js:4:1 › Visit Page (7s)
✓  [chromium] › tests/example.spec.js:4:1 › Visit Page (3s)
✓  [webkit] › tests/example.spec.js:4:1 › Visit Page (2s)

3 passed (8s)
</code></pre>

        <p>
            Running tests in all rendering engines is certainly definitive, but what if we want to test something a little 
            quicker, and are satisfied with just use one? To run just one of our "projects" from the config file we created, 
            you can run <code>npx playwright test --project=chromium</code>.
        </p>

        <p>
            Let's provide an incorrect page title to our test expectation in order to see what happens if our test fails.
            In the following output, Playwright provides some meaningful output such as expected/received values, and 
            a call log for debugging purposes.
        </p>

        <pre><code>1) [chromium] › tests/example.spec.js:8:1 › Visit Page ===========================

Error: expect(received).toBe(expected) // Object.is equality

Expected: "JointJS Ap"
Received: "JointJS App"

    14 |     });
    15 |     const pageTitle = await page.title();
  > 16 |     expect(pageTitle).toBe('JointJS Ap');
       |                       ^
    17 | });
</code></pre>

        <p>
            Running this test in a headed browser may not be too beneficial, but let's see how we can achieve that.
            <code>npx playwright test --headed</code> will run our test for each of our "projects". As the test just visits a page, that
            means Playwright will show us the respective browsers for a very short time, and that's to be expected.
        </p>

        <p>
            As we want to make our lives as easy as possible, we will also configure a few npm scripts for testing. Playwright Test will 
            automatically pick up a <code>playwright.config.js</code> file located in our project root. In our <code>package.json</code> file, 
            <code>npm run test</code> will run each of our projects for each test spec in headless browsers, and 
            <code>npm run test:chromium</code> will just run tests using the chromium rendering engine. This isn't anything special,
            and just covers the commands we have already used so far. 
        </p>

        <pre><code>{
    "scripts": {
        "test": "playwright test",
        "test:chromium": "playwright test --project=chromium"
    }
}
</code></pre>

        <h3 id="heading">
            Heading
        </h3>

        <p>
            After performing a test to check if your app is served correctly, you my want to perform some other simple sanity checks.
            A good example could be checking if the text in your application is displayed correctly. Playwright provides some nice 
            <a href="https://playwright.dev/docs/selectors" target="_blank"><code>Selectors</code></a> to target elements. As we want our testing to 
            be as robust and reliable as possible, we will prioritize user-facing attributes, that means we will use mainly text or CSS selectors.
        </p>

        <p>
            We are going to target our primary app heading as we know it is content that rarely changes, and isn't impacted by DOM structure
            changes. In the following example, our CSS selector is used by a 
            <a href="https://playwright.dev/docs/locators" target="_blank"><code>Locator</code></a>. Locators allow us to perform actions on 
            elements such as a click for example. A nice feature of Locators is that they are strict by design, that means operations on locators 
            will throw an exception if more than one element matches a given selector. This is great for our primary heading as we know it is 
            a unique piece of content on our page.
        </p>

        <p>
            You'll also notice, we have added a test hook <code>test.beforeAll</code>. As we want our app to be served for all our tests,
            the hook provides this nice functionality for us.
        </p>

        <pre><code>const { test, expect } = require('@playwright/test');
            
test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000/');
});
          
test('Primary heading isDisplayed', async ({ page }) => {
    const heading = page.locator('.heading__primary');
    await expect(heading).toHaveText('JointJS App');
});
</code></pre>



       <p>
           With JointJS, there are some common testing scenarios you might like to test. We will look at some of those situations in 
           the following section.
       </p>

        <h3 id="dragging-elements">
            Dragging Elements
        </h3>

        <p>
            An important part of any diagramming library is the ability to drag elements. What if we wanted to automate the testing 
            of dragging an element from one area of our application to another? Playwright provides an API which makes this easy to
            implement in a few different ways. In the following example, we use the <code>locator.dragTo()</code> method. Similar 
            techniques might be used in JointJS+ for dragging an element from the 
            <a href="https://resources.jointjs.com/docs/rappid/v3.5/ui.Stencil.html" target="_blank">ui.Stencil</a>
            plugin to the JointJS <code>paper</code>.
        </p>

        <pre><code>test('Drag element to target area', async ({ page }) => {
    const source = page.locator('text=source');
    const target = page.locator('text=area');
    await source.dragTo(target);
});
</code></pre>

        <h3 id="link-elements">
            Link Elements
        </h3>

        <p>
            Another common pattern you may want to test is the linking of Elements in JointJS. In the following example we take advantage
            of the Playwright mouse API to draw a link from the port of one element to another.
        </p>

        <pre><code>test('Link Elements', async ({ page }) => {
    const source = page.locator('.joint-port-body');
    const sourceBbox = await source.boundingBox();

    const target = page.locator('text=label');
    const targetBbox = await target.boundingBox();

    // Check if 0 links are in the graph
    const link = page.locator('.joint-type-standard-link');
    await expect(link).not.toBeVisible();

    // Mousemove to center of element
    await page.mouse.move(sourceBbox.x + sourceBbox.width / 2, sourceBbox.y + sourceBbox.height / 2);
    await page.mouse.down();
    await page.mouse.move(targetBbox.x, targetBbox.y);
    await page.mouse.up();

    // Check if a link is in the graph after mousemove
    await expect(link).toHaveCount(1);
});
</code></pre>

        <h3 id="drag-and-drop">
            Drag & Drop
        </h3>

        <p>
            Playwright provides nice functionality to test Drag & Drop right out of the box. We simply use the <code>page.dragAndDrop()</code> method,
            and provide our source and target as arguments.
        </p>

        <pre><code>test('Drag and Drop', async ({ page }) => {
    await page.dragAndDrop('text=source', 'text=area');
});
</code></pre>

        <h3 id="user-input-and-dynamic-attributes">
            User Input and dynamic attributes
        </h3>

        <p>
            Dynamic content is central to most modern applications, and if you are using JointJS, you probably want to test this scenario too.
            In the following situation, the user fills a text input field, and the value of this input, will also be the value of our element label.
            If you are a user of JointJS+, you might have a similar situation you would like to test using our 
            <a href="https://resources.jointjs.com/docs/rappid/v3.5/ui.Inspector.html" target="_blank">ui.Inspector</a> plugin.
        </p>

        <pre><code>test('User input changes element attribute', async ({ page }) => {
    await page.fill('input', 'Hi');

    const rect = page.locator('.joint-type-standard-rectangle');
    await expect(rect).toHaveText('Hi');
});
</code></pre>

        <h3 id="visual-regression">
            Visual Regression
        </h3>

        <p>
            As we want to maintain a consistent visual state for our JointJS application, we will also perform a test to see if our app has regressed 
            visually in some manner. Playwright Test allows us to produce and visually compare screenshots. Let's create a new file in our tests folder 
            <code>visual-regression.spec.js</code>, and add the following test.
        </p>

        <pre><code>const { test, expect } = require('@playwright/test');

test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000/');
});

test('visual regression', async ({ page }) => {
    expect(await page.screenshot()).toMatchSnapshot();
});
</code></pre>

        <p>
            On the first test run, it will generate reference screenshots, and subsequent test runs will compare against the reference. On the first run, 
            you should see some output similar to the following error, but don't worry, that's expected because there isn't any "golden" file for comparison
            yet.
        </p>

        <pre><code>// Error: example.spec.ts-snapshots/example-test-1-chromium-darwin.png is missing in snapshots, writing actual.
</code></pre>

        <p>
            After comparing your "golden" snapshot with the current state of your application, it's only natural that you may need to make further changes
            to visual aspects of your project. In this case, you will need to update your snapshots in order for visual regression tests to run successfully
            again. To update snapshots, you can run the following command:
        </p>

        <pre><code>npx playwright test --update-snapshots
</code></pre>

        <script src="../node_modules/prismjs/prism.js"></script>

    </body>
</html>
