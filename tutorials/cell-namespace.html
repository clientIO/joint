<!DOCTYPE html>
<html lang="en">
    <head>

        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />
        <meta name="keywords" content="JointJS, JavaScript, diagrams, diagramming library, UML, charts" />

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prism-themes/themes/prism-one-light.css">

        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>

        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>

    </head>
    <body class="language-javascript tutorial-page">

        <div class="tutorial">

            <h1>Cell Namespace</h1>

            <!-- <ul>
                <li>Custom View needs to be set up in the same manner</li>
            </ul> -->

            <p>
                A simple, but important aspect of working with JointJS is to ensure that JointJS knows where to look for built-in and custom shapes.
                In order to achieve this, it's a requirement to tell JointJS where to read cell view definitions. Failure to do so
                will result in an error in our application. Built-in shapes are usually located in the <code>joint.shapes</code> namespace, so this 
                is a common namespace to use. It's possible to add custom shapes to this namespace, or alternatively, you may like to use a different 
                namespace completely. The choice is yours, but you need to state the namespace at the outset when using JointJS.
            </p>

            <p>
                How do we tell JointJS which namespace to use? There are 2 important options to be aware of when creating your diagrams. The
                first is the <code>graph</code> option <code>cellNamespace</code>, and the second is the <code>paper</code> option 
                <code>cellViewNamespace</code>. In the following example, for a cell of type <code>'standard.Rectangle'</code>, the 
                <code>graph</code> looks up the <code>'joint.shapes.standard.Rectangle'</code> path to find the correct constructor. If you don't 
                plan on creating custom shapes, or playing around with namespaces, the following setup should be fine for your application.
            </p>

            <pre><code>const namespace = joint.shapes;
            
const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

const paper = new joint.dia.Paper({
    ...
    cellViewNamespace: namespace
    ...
});

graph.fromJSON({
    cells: [
        { 
            type: 'standard.Rectangle', 
            size: { width: 80, height: 50 },
            position: { x: 10, y: 10 }
        }
    ]
});
</code></pre>

            <p>
                On the other hand, if you are feeling a little adventurous, and would like to create your own namespace, the following example may
                interest you. Supposing you wanted a custom namespace which contains just 2 built-in JointJS shapes. How would you go about this?
                Using destructuring, we can retrieve the shapes we want from the <code>joint.shapes.standard</code> namespace, and then add the
                shapes to our <code>customNamespace</code>.
            </p>

            <p>
                It's important to note that while our custom namespace is just an object that contains our <code>Link</code> and 
                <code>Rectangle</code> constructors, the default <code>type</code> property of each cell created will still state the location as 
                within the <code>standard</code> namespace. In order to set up namespaces correctly, this is something we will have to address.
            </p>

            <p>
                Below, the <code>prop()</code> method is used to update the type, so JointJS no longer looks for the constructor within a namespace 
                <code>standard</code>, but at the top level of our <code>customNamespace.</code> This in turn means that after adding the 
                <code>rect</code> element to the <code>graph</code>, overwriting the <code>graph</code> with <code>graph.toJSON()</code> passing 
                in the value returned from <code>graph.toJSON()</code> does not result in an error. This is confirmation that our namespaces are 
                set up correctly.
            </p>

            <pre><code>const { Rectangle, Link } = joint.shapes.standard;
            
const customNamespace = { Rectangle, Link };
            
const graph = new joint.dia.Graph({}, { cellNamespace: customNamespace });

const paper = new joint.dia.Paper({
    ...
    cellViewNamespace: customNamespace
    ...
});

// Including "type: 'Rectangle'" when creating an instance would accomplish the same as using prop()
const rect = new Rectangle({
    size: { width: 80, height: 50 },
    position: { x: 10, y: 10 }
});

console.log(rect.prop('type')); // standard.Rectangle
rect.prop('type', 'Rectangle');
console.log(rect.prop('type')); // Rectangle

rect.addTo(graph);

graph.fromJSON(graph.toJSON());
</code></pre>

            <p>
                If we were to continue using <code>'standard.Rectangle'</code> as our type in the 2nd example, this would result in a common error 
                in JointJS. If you see the dreaded error <code>Uncaught Error: dia.ElementView: markup required</code> appearing in your console,
                it's likely your namespace is not set up correctly, and JointJS cannot find the correct shape.
            </p>

            <h2 style="font-size:19px;text-align:initial;text-transform:none;margin:0;">A More Detailed Look</h2>
            
            <p>
                In order to strengthen this concept in our minds, let's create a few more shapes, so that we are more familiar with this process. 
                In the following example, we create a class <code>RectangleTwoLabels</code> with a <code>type</code> property of 
                <code>'custom.RectangleTwoLabels'</code>. JointJS now expects that our custom <code>RectangleTwoLabels</code> element will be located 
                within the <code>'custom'</code> namespace.
            </p>

            <p>
                As we want our <code>'custom'</code> namespace to be at the same level of nesting as built-in JointJS shapes, we will structure our 
                cell namespace accordingly. First, we create an object variable <code>namespace</code>, then using the 
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" target="_blank">spread operator</a>,
                ensure that <code>namespace</code> contains all of the properties of <code>joint.shapes</code>. These properties correspond to shape 
                namespaces such as <code>'standard'</code>.
            </p>

            <p>
                Afterwards, taking advantage of 
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank"><code>Object.assign()</code></a>, 
                the properties of <code>customNamespace</code> are copied to our <code>namespace</code> object. The result is that 
                <code>'standard'</code> and <code>'custom'</code> are both defined at the same level in our <code>namespace</code> object.
            </p>

            <p>
                Lastly, we make sure that <code>namespace</code> is set as the value of our <code>cellNamespace</code> and <code>cellViewNamespace</code>
                properties respectively.
            </p>
            
            <pre><code>class RectangleTwoLabels extends joint.shapes.standard.Rectangle {
    defaults() {
        return {
            ...super.defaults,
            type: 'custom.RectangleTwoLabels'
        };
    }
    
    preinitialize() {
        this.markup = joint.util.svg/* xml */ `
            &lt;rect @selector="body" /&gt;
            &lt;text @selector="label" /&gt;
            &lt;text @selector="labelSecondary" /&gt;
        `;
    }
}

const namespace = { ...joint.shapes };
const customNamespace = { custom: { RectangleTwoLabels }}; 

Object.assign(namespace, customNamespace);

const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

new joint.dia.Paper({
    ...
    cellViewNamespace: namespace
    ...
});
</code></pre>

            <pre><code>graph.fromJSON({
    cells: [
        {
            type: 'standard.Rectangle', 
            size: { width: 100, height: 60 },
            position: { x: 50, y: 50 },
            attrs: { label: { text: 'standard.Rectangle', textWrap: { width: 'calc(w-10)' }}}
        },
        { 
            type: 'custom.RectangleTwoLabels', 
            size: { width: 140, height: 80 },
            position: { x: 180, y: 30 },
            attrs: { 
                label: { 
                    text: 'custom.RectangleTwoLabels',
                    textWrap: { width: 'calc(w-10)' } 
                }, 
                labelSecondary: { 
                    text: 'SecondaryLabel', 
                    x: 'calc(w/2)', 
                    y: 'calc(h+15)', 
                    textAnchor: 'middle', 
                    textVerticalAnchor: 'middle',
                    fontSize: 14 
                }
            }
        },
    ]
});
</code></pre>
            
            <div class="paper" id="paper-cell-namespace"></div>
            <p>JointJS source code: <a href="js/cell-namespace.js" target="_blank">cell-namespace.js</a></p>

            <h2 style="font-size:19px;text-align:initial;text-transform:none;margin:0;">Create Custom Views in same manner</h2>

        </div><!--end tutorial-->

        <script src="../node_modules/prismjs/prism.js"></script>

        <script src="js/cell-namespace.js"></script>
    </body>
</html>
