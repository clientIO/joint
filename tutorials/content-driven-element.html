<!DOCTYPE html>
<html>
    <head>

        <link rel="canonical" href="http://www.jointjs.com/" />
        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />
        <meta name="keywords" content="JointJS, JavaScript, diagrams, diagramming library, UML, charts" />

        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prismjs/themes/prism.css">

        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>

        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>

    </head>
    <body class="language-javascript tutorial-page">

        <script>
            SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function(toElement) {
                return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
            };
        </script>
        <div class="tutorial">

            <h2>Content Driven Elements</h2>

            <p>
                JointJS provides its users flexibility when it comes to creating custom shapes. You may have already taken
                advantage of this flexibility by using traditional JointJS mechanisms such as markup and attributes. That is 
                a well-established method of creating custom elements, but it's not the only approach that you could utilize.
            </p>

            <p>
                Another way to create custom elements is to allow the content to drive the appearance of the element itself.
                This means we don't set the element sizing explicitly, but allow the element dimensions to be derived from the 
                content.
            </p>

            <p>
                Depending on your use case, a content driven element may not be essential for your workflow, so you may ask why
                would I need to use one?
            </p>

            <p>
                Imagine you are working with a lot of data points, what if each one has a label of different length, and you
                want to make sure the label doesn't extend beyond its element bounds? In this instance, it might not be desirable
                to set the element's size in retrospect. It is possible a more efficient workflow would be to allow the label
                content to drive element sizing instead.
            </p>

            <p>
                With content driven elements, you are not limited to what content drives the element appearance, but as the most common
                types of content are probably text and images, we will focus on those in this tutorial.
            </p>

            <div id="paper-content-driven-element"></div>
            <script type="text/javascript" src="js/content-driven-element.js"></script>
            <p>JointJS source code: <a href="js/content-driven-element.js" target="_blank">content-driven-element.js</a></p>

            <h3>Shape definition</h3>

            <p>
                The first step towards content driven elements is to define our shape. We start by creating a <code>Shape</code>
                class which inherits from <code>joint.dia.Element</code>. Since we aren't using traditional <code>markup</code>, 
                or presentation <code>attrs</code>, we simply provide just a few default properties we want to work with.
            </p>

            <p>
                <code>type</code> defines the namespace where JointJS looks for our shape. As <code>joint.shapes</code> is implied,
                the full path will be <code>joint.shapes.custom.Shape</code>. The remaining default attributes on our model are related to 
                the visual aspects of our shape. As these attributes are updated on our model, we would like the view to update too.
            </p>

<pre><code>class Shape extends joint.dia.Element {
    defaults() {
        return {
            ...super.defaults,
            type: 'custom.Shape',
            fillColor: 'red',
            outlineColor: 'blue',
            label: '',
            image: ''
        };
    }
}
</code></pre>

            <p>
               The main magic of our content driven element happens in a layout function. As we want our layout to have access to
               certain model properties during calculation, we should <code>preinitialize()</code> our instances with those properties.
            </p>

<pre><code>preinitialize() {
    this.spacing = 10;
    this.labelAttributes = {
      'font-size': 14,
      'font-family': 'sans-serif',
    };
    this.imageAttributes = {
      'width': 50,
      'height': 50,
      'preserveAspectRatio': 'none'
    };
    this.cache = {};
}
</code></pre>

            <p>
                When we <code>initialize()</code> our shape instance, we add an event listener to detect changes in labels and 
                images as those are the types of content that affect our layout.
            </p>

            <p>
                We also set the size of our element based on the width and height derived from our layout function.
            </p>

<pre><code>initialize() {
    super.initialize();
    this.on('change', this.onAttributeChange);
    this.setSizeFromContent();
}

/* Attributes that affects the size of the model. */
onAttributeChange() {
    const {
      changed,
      cache
    } = this;
    if ('label' in changed) {
      // invalidate the cache only if the text of the `label` has changed
      delete cache.label;
    }
    if ('label' in changed || 'image' in changed) {
      this.setSizeFromContent();
    }
}

setSizeFromContent() {
    delete this.cache.layout;
    const {
      width,
      height
    } = this.layout();
    this.resize(width, height);
}
</code></pre>

            <p>
                Next we will highlight the layout of our element, and how it's created. As you can see, our <code>calcLayout()</code> 
                method utilizes the properties we createdearlier.
            </p>

            <p>
                The function focuses on returning metrics for the <code>width</code> and <code>height</code> of our element, and also 
                the dimensions for our label and image.
            </p>

<pre><code>layout() {
    const {
        cache
    } = this;
    let {
        layout
    } = cache;
    if (layout) {
        return layout;
    } else {
        const layout = this.calcLayout();
        cache.layout = layout;
        return layout;
    }
}
    
calcLayout() {
    const {
        attributes,
        labelAttributes,
        imageAttributes,
        spacing,
        cache
    } = this;
    let width = spacing * 2;
    let height = spacing * 2;
    let x = spacing;
    let y = spacing;
    // image metrics
    let $image;
    if (attributes.image) {
        const {
            width: w,
            height: h
        } = imageAttributes;
        $image = {
            x,
            y,
            width: w,
            height: h
        };
        height += spacing + h;
        y += spacing + h;
        width += w;
    } else {
        $image = null;
    }
    // label metrics
    let $label; {
        let w, h;
        if ('label' in cache) {
            w = cache.label.width;
            h = cache.label.height;
        } else {
            const {
                width,
                height
            } = measureText(svg, attributes.label, labelAttributes);
            w = width;
            h = height;
            cache.label = {
                width,
                height
            };
        }
        width = Math.max(width, spacing + w + spacing);
        height += h;
        if (!h) {
            // no text
            height -= spacing;
        }
        $label = {
            x,
            y,
            width: w,
            height: h
        };
    }
    // root metrics
    return {
        x: 0,
        y: 0,
        width,
        height,
        $image,
        $label
    };
}
</code></pre>

        <h3>Custom Shape View</h3>

        <p>
            Another important aspect of our content driven element is our custom element view. The view is responsible for rendering
            our shape, and also working with our element visually. Our custom view will listen to the underlying model changes, and
            update itself.
        </p>

        <p>
            <code>addPresentationAttributes()</code> extends the <code>CellView</code> presentation attributes, with more attributes,
            and makes sure the original CellView attributes are preserved.
        </p>

        <p>
            An important note about the view is that, when it needs an update, it first requests that update from the <code>paper</code>.
            Update requests are sent to the paper via flags. To sum up <code>presentationAttributes</code>, it is an object that maps 
            attributes to these flag labels. <code>confirmUpdate()</code> receives all scheduled flags, and based on them updates the view.
            In our example, <code>confirmUpdate</code> doesn't resize DOM elements if the received flag is <code>'@color'</code>.
        </p>

<pre><code>const ElementView = joint.dia.ElementView;

const ShapeView = ElementView.extend({

    presentationAttributes: ElementView.addPresentationAttributes({
        // attributes that changes the position and size of the DOM elements
        label: [ElementView.Flags.UPDATE],
        image: [ElementView.Flags.UPDATE],
        // attributes that do not affect the size
        outlineColor: ['@color'],
        fillColor: ['@color'],
    }),

    confirmUpdate: function(...args) {
        let flags = ElementView.prototype.confirmUpdate.call(this, ...args);
        if (this.hasFlag(flags, '@color')) {
            // if only a color is changed, no need to resize the DOM elements
            this.updateColors();
            flags = this.removeFlag(flags, '@color');
        }
        // must return 0
        return flags;
    }

});
    
joint.shapes.custom = {
    Shape,
    ShapeView
};
</code></pre>

        <p>
            The <code>render()</code> function runs once during initialization, and calls the relevant functions
            for updating our element. 
        </p>

<pre><code>/* Runs only once while initializing */
render: function() {
    const {
        vel,
        model
    } = this;
    const body = this.vBody = V('rect').addClass('body');
    const label = this.vLabel = V('text').addClass('label').attr(model.labelAttributes);
    this.vImage = V('image').addClass('image').attr(model.imageAttributes);
    vel.empty().append([
        body,
        label
    ]);
    this.update();
    this.updateColors();
    this.translate(); // default element translate method
},

update: function() {
    const layout = this.model.layout();
    this.updateBody(layout);
    this.updateImage(layout.$image);
    this.updateLabel(layout.$label);
},

updateColors: function() {
    const {
        model,
        vBody
    } = this;
    vBody.attr({
        fill: model.get('fillColor'),
        stroke: model.get('outlineColor')
    });
},

updateBody: function() {
    const {
        model,
        vBody
    } = this;
    const {
        width,
        height
    } = model.size();
    const bodyAttributes = {
        width,
        height
    };
    vBody.attr(bodyAttributes);
},

updateImage: function($image) {
    const {
        model,
        vImage,
        vel
    } = this;
    const image = model.get('image');
    if (image) {
        if (!vImage.parent()) {
            vel.append(vImage);
        }
        vImage.attr({
            'xlink:href': image,
            x: $image.x,
            y: $image.y
        });

    } else {
        vImage.remove();
    }
},

updateLabel: function($label) {
    const {
        model,
        vLabel
    } = this;
    vLabel.attr({
        'text-anchor': 'middle',
        x: $label.x + $label.width / 2,
        y: $label.y + $label.height / 2
    });
    vLabel.text(model.get('label'), {
        textVerticalAnchor: 'middle'
    });
}
</code></pre>

            <p>
                Lastly, we make an instance of our shape with the techniques you are familiar with.
            </p>

<pre><code>const customShape4 = new Shape();
customShape4
    .set('image', 'https://via.placeholder.com/150/FF0000')
    .set('label', 'Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit.\nInteger vehicula.')
    .set('outlineColor', 'red')
    .position(200, 50)
    .prop('fillColor', 'lightgray')
    .addTo(graph);
</code></pre>

        <p>
            Thanks for reading. I hope you consider content driven elements if it's suitable for your application.
            If you would like to explore any of the features mentioned here in more detail, you can find extra information in our 
            <a href="/docs/jointjs" target="_blank">JointJS documentation</a>. 
        </p>

        </div><!--end tutorial-->

        <script src="../node_modules/prismjs/prism.js"></script>
    </body>
</html>
