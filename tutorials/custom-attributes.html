<!DOCTYPE html>
<html lang="en">
<head>

    <link rel="canonical" href="http://www.jointjs.com/"/>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
          content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use."/>
    <meta name="keywords" content="JointJS, JavaScript, diagrams, diagramming library, UML, charts"/>

    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet" type="text/css"/>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

    <link rel="stylesheet" href="css/tutorial.css"/>
    <link rel="stylesheet" href="../node_modules/prismjs/themes/prism.css">

    <!-- Dependencies: -->
    <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />

    <title>JointJS - Create custom attributes with prop() and set()</title>

</head>
<body class="language-javascript tutorial-page">
    <div class="tutorial">

    <h2>Custom Attributes</h2>

    <p>
        If you have been working with JointJS for any amount of time, you are probably familiar with presentation attributes.
        These are the attributes which contribute to the visual aspect of our shape, and are mostly defined through
        <code>attrs</code> objects. While presentation attributes provide us with great functionality, occasionally we might want 
        to create our own attributes to help us work with our shape. This is where custom attributes come in useful. Maybe we 
        want a boolean to represent a state, a number for our threshold value, or just provide some attributes which represent our 
        specific problem, all of these could be possible use cases for a custom attribute.
    </p>

    <p>
        To work with presentation attributes, we usually use the <code>attr()</code> method. However, when working with custom
        attributes, we suggest working with <code>prop()</code> and <code>set()</code>. These methods will help you store
        custom data on the model, while at the same time also providing a nice separation between custom and presentation attributes 
        if needed.
    </p>

    <h3>prop()</h3>

    <p>
        <i>Prop</i> is used to set attributes on the element model. It can be used to set both custom and presentation attributes, and
        it also provides support for nesting making it very flexible. When setting an attribute, the first parameter is an object or 
        string representation of your path, and the second parameter will be the value you wish to set. Prop will merge the properties
        you want to set with existing ones already present in the Cell.
    </p>

    <pre><code>
    element.prop('attrs/body/stroke', '#FFF'); // Set presentation attribute

    element.prop('data', 10); // Set custom attribute with path
    element.prop({ data: 10 }); // Set custom attribute with object 

    export class Rect extends shapes.standard.Rectangle {
        defaults() {
            return util.defaultsDeep({
                type: 'app.Rect',
                data: 10, // Our custom attribute
                attrs: {
                ...
                    body: {
                        stroke: '#FFF', // Our presentation attribute
                    },
                ...
                }
            }, super.defaults);
        }
        ...
    }



    element.prop('data/count', 10); // Set nested custom attribute with path
    element.prop({ data: { count: 10 }}); // Set nested custom attribute using object

    export class Rect extends shapes.standard.Rectangle {
        defaults() {
            return util.defaultsDeep({
                type: 'app.Rect',
                data: {
                    count: 10 // Our nested custom attribute
                },
                attrs: {
                ...
                }
            }, super.defaults);
        }
        ...
    }
    </code></pre>

    <p>
        <code>prop()</code> not only provides support for nested objects, but for nested arrays too.
    </p>

    <pre><code>
    element.prop('mylist/0/data/0/value', 50); // Set custom attribute as nested array
    
    
    export class Rect extends shapes.standard.Rectangle {
        defaults() {
            return util.defaultsDeep({
                type: 'app.Rect',
                mylist: [{
                    data: [{
                        value: 50 // Our custom attribute 
                    }]
                }],
                attrs: {
                ...
                }
            }, super.defaults);
        }
        ...
    }
    </code></pre>

    <h3>set()</h3>

    <p>
        <i>Set</i> is a method provided by <i>backbone.js</i>, and similarly to <code>prop()</code>, it can be used to create custom data 
        attributes on the element model. Like <code>prop()</code>, when setting an attribute, the first parameter can be an object 
        or string, but <code>set()</code> doesn't provide nesting capability in the form of a string. That means any path representation 
        is considered to be one attribute. Again, the second parameter is the value you wish to set. Another difference to take note of
        is that <code>set()</code> will override attributes while <code>prop()</code> merges them.
    </p>

    <pre><code>
    element.set('data', 10); // Set custom attribute with path
    element.set({ data: 10 }); // Set custom attribute with object


    export class Rect extends shapes.standard.Rectangle {
        defaults() {
            return util.defaultsDeep({
                type: 'app.Rect',
                data: 10, // Our custom attribute
                attrs: {
                ...
                }
            }, super.defaults);
        }
        ...
    }



    element.set('data/count', 10); // We try to set a nested custom property using set()

    // The output produced will not be nested as is the case when using prop()
    
    export class Rect extends shapes.standard.Rectangle {
        defaults() {
            return util.defaultsDeep({
                type: 'app.Rect',
                data/count: 10, // Note the important difference here
                attrs: {
                ...
                }
            }, super.defaults);
        }
        ...
    }
    </code></pre>

    <h3>Relationship between prop() and attr()</h3>

    <p>
        Both of these methods function similarly, but there are a few small differences to be aware of. Internally, <code>attr()</code>
        implements <code>prop()</code> to process our attributes. Afterwards, the method places the presentation attributes within 
        the <code>attrs</code> object. Separating attributes in this manner also provides our model with a nice semantic
        and organizational divide between our custom and presentation properties.
    </p>

    <pre><code>

    </code></pre>

    <p>
        If you would like to explore any of the features mentioned here in more detail, you can find extra information in our 
        <a href="https://resources.jointjs.com/docs/jointjs/v3.3/joint.html" target="_blank">JointJS documentation</a>.
    </p>

    </div><!--end tutorial-->
    <script src="../node_modules/prismjs/prism.js"></script>
</body>
</html>
