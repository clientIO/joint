<!DOCTYPE html>
<html>
    <head>

        <link rel="canonical" href="http://www.jointjs.com/" />
        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />
        <meta name="keywords" content="JointJS, JavaScript, diagrams, diagramming library, UML, charts" />

        <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prismjs/themes/prism.css">


        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/index.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>


        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>

    </head>
    <body class="language-javascript tutorial-page">

        <script>
            SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function (toElement) {
                return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
            };
        </script>

        <div id="custom-elements" class="tutorial">

            <h2>Custom Elements</h2>

            <p>This is the fourth article of the intermediate section of the JointJS tutorial.
                <a href="serialization.html">Go back to serialization.</a>
                Alternatively, you can <a href="intermediate.html">return to index</a> of all articles.</p>

            <p>JointJS comes with several collections of built-in shapes in addition to the default
                <code>joint.dia.Element</code> and <code>joint.dia.Link</code> classes.
                We already saw a few shapes from the <code>joint.shapes.standard</code> collection in the basic
                <a href="elements.html">element</a> and <a href="links.html">links</a> demos.
                Additionally, JointJS has plugins that contain shape and link definitions for components of some
                well-known diagramming languages.</p>

            <p>However, even though there are many default shapes to choose from, you might find that you are missing
                one and want to create your own shape definition.
                Creating new shapes is very simple in JointJS if you already know SVG.
                The most important SVG elements are <code>rect</code>, <code>text</code>, <code>circle</code>,
                <code>ellipse</code>, <code>image</code> and <code>path</code>.
                Their thorough description with examples and illustrations can be found elsewhere on the Internet, e.g.
                on <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element" target="_blank">MDN</a>.
                What is important for us is to realize that combining the basic SVG shapes, we can define any 2D shape
                we need.</p>

            <p>For that, we use a builtin JointJS function:</p>

            <ul>
                <li><a href="/docs/jointjs#dia.Cell.define"><code>joint.dia.Element.define()</code></a> - define a new
                Cell class of the given name.
                Optionally, you can provide default instance properties, prototype properties, and static
                properties of the class.</li>
            </ul>

            <h3>Identifier</h3>

            <p>The first argument of the <code>define()</code> function is an unique identifier under which you want to
                be able to find the new type.
                You can then instantiate the class by calling <code>new joint.shapes.CustomType()</code>.</p>

            <h3>Markup</h3>

            <!--<p>The second argument of the <code>define()</code> function is the most interesting.
                It allows you to specify the default properties of instances of the new type.
                Elements have two crucial properties - <code>markup</code> and <code>attrs</code>.
                We talked a little bit about element attributes in the <a href="elements.html#element-styling">basic
                section of the tutorial</a>, but we have never mentioned markup before.</p>-->

            <p>Markup is usually provided inside the third argument of the <code>define()</code> function (prototype
                properties); this is because markup is something that all instances of the element type are expected to
                have in common.
                Markup is specified in JSON format.
                (JointJS also supports specifying the markup as a string with SVG tags, but that approach is noticeably
                slower due to the need for parsing.
                Therefore, we encourage everyone to use the JSON markup.)
                An array is expected, with each member of the array representing one subelement of the new shape.
                Subelements are represented with objects containing a <code>tagName</code> (a string with the SVG tag
                name of the subelement) and optionally a <code>selector</code> (a string identifier for this subelement
                in the shape).
                For example, the familiar <code>joint.shapes.standard.Rectangle</code> has the following
                <code>markup</code> in its definition:</p>

            <pre><code></code></pre>

            <p> As it was mentioned, custom elements are created by combining SVG tags. Many times, it is useful to position
                one
                element relatively to another. Imagine a basic situation where you want to have a rectangle element and a
                text element that should always be in the center of the rectangle.
                Unfortunately, SVG does not provide a facility to do that. Therefore, JointJS introduces
                <a href="/docs/jointjs/v1.0/joint.html#specialAttributes" target="_top">special attributes</a> that are helpful for positioning elements relatively
                to each other. For an example, let's explore how the
                <code>joint.shapes.basic.Rect</code> element is defined:
            <pre><code>joint.shapes.basic.Rect = joint.shapes.basic.Generic.extend({
    markup: '&lt;g class="rotatable"&gt;&lt;g class="scalable"&gt;&lt;rect/&gt;&lt;/g&gt;&lt;text/&gt;&lt;/g&gt;',

    defaults: joint.util.deepSupplement({
        type: 'basic.Rect',
        attrs: {
            'rect': { fill: 'white', stroke: 'black', 'follow-scale': true, width: 80, height: 40 },
            'text': { 'font-size': 14, 'ref-x': .5, 'ref-y': .5, ref: 'rect', 'y-alignment': 'middle', 'x-alignment': 'middle' }
        }
    }, joint.shapes.basic.Generic.prototype.defaults)
});</code></pre>

            As you can see, the SVG tags are stored in a property <code>markup</code>. This property contains an SVG
            template for the <code>joint.shapes.basic.Rect</code> element.
            There are two important SVG groups in the markup that JointJS understands. The first one is the one with the
            class <code>"rotatable"</code>. All elements
            in this group will get rotated when the <a href="/docs/jointjs/v1.0/joint.html#dia.Element.prototype.rotate" target="_top">joint.dia.Element.rotate()</a>
            method is called.
            The other group is <code>"scalable"</code>. All elements in this group will get scaled when
            the <a href="/docs/jointjs/v1.0/joint.html#dia.Element.prototype.resize" target="_top">joint.dia.Element.resize()</a> method is called.

            <p>
                All the positioning and presentation definitions are then stored as usual in the <code>attrs</code> object.
                Notice
                the special attributes <code>ref-x</code>, <code>ref-y</code>, <code>ref</code>, <code>x-alignment</code>
                and <code>y-alignment</code>.
                <code>ref-x</code> and <code>ref-y</code> determine the position of the <code>text</code> SVG element
                relative to
                an element referenced to by the selector stored in the <code>ref</code> attribute. In our case, the <code>text</code>
                element is positioned 50% in the x-axis and 50% in the y-axis relative to the <code>rect</code> element,
                i.e. in the center of the rectangle.
                <code>x-alignment === 'middle'</code> and <code>y-alignment === 'middle'</code> causes the text to center
                itself around its x-axis and y-axis. If we didn't do that,
                only the left-corner of the text element would be in the center of the rectangle but not the whole text.
            </p>
            <p>
                Notice that in this case, we don't want the text to scale, only the rectangle (that's why the text is not
                inside the "scalable" group in the markup). But because we set the
                relative positioning attributes on the text, the text will move in order to put itself to the center of the
                rectangle
                even though the center moved due to the scale operation on the rectangle. Isn't this nice?
            </p>
            <p>SVG + JointJS relative positioning attributes make it easy to create custom elements in a declarative
                fashion. It just
                needs a little bit of practice and try-fail loops.</p>

            <p><a href="custom-links.html">In the next section of the intermediate tutorial, we will learn about
                creating custom links.</a></p>

        </div><!--end tutorial-->

        <script src="../node_modules/prismjs/prism.js"></script>

    </body>
</html>
