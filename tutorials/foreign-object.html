<!DOCTYPE html>
<html lang="en">
    <head>

        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prism-themes/themes/prism-one-light.css">

        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>


        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <link rel="stylesheet" href="css/foreign-object.css">
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>
    </head>
    <body class="language-javascript tutorial-page">


        <div id="foreign-object" class="tutorial">

            <h1>Foreign Object</h1>

            <p>
                In the wonderful world of SVG elements, 
                <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject" target="_blank"><code>foreignObject</code></a> 
                stands out from the rest as it provides some unique behaviour that other SVG elements do not. SVG, like other XML dialects, is
                namespaced. That means if you want to include elements from a different XML namespace right in your SVG, you need some
                mechanism to enable this functionality. That's where <code>foreignObject</code> comes into play.
                How does this relate to creating diagrams with JointJS? While JointJS provides a lot of functionality and customization
                for users, we as developers are a habitual bunch. If we want to create some basic interactive elements, we often want to
                reach for technologies we are already familiar with, and in web land, the dominant force in this regard is still good old HTML.
            </p>

            <p>
                Historically, recommending <code>foreignObject</code> to users of JointJS was a little bit tricky, the main reason for this was the
                inherent lack of support for <code>foreignObject</code> in Internet Explorer. Due to the necessity of supporting all our users,
                including those who were still using IE, there was a hesitancy about integrating support into the library fully. Luckily for us, 
                the days in which we had to support IE are now at an end, and all other major browsers have full support, as illustrated by this
                <a href="https://caniuse.com/?search=foreignObject" target="_blank">caniuse</a> reference table.
            </p>

            <p>
                Now, that we can more confidently recommend the use of <code>foreignObject</code> with JointJS, embedding HTML text in SVG, 
                creating basic interactive elements like buttons, or working with HTML inputs should be a more straightforward process. 
                With this addition, combining the power of JointJS with <code>foreignObject</code> opens up a world of possibilities for 
                interactivity within your JointJS diagrams.
            </p>

            <p>
                In order to get a general idea of how <code>foreignObject</code> can be utilized in SVG, let's start with a simple 
                example without using JointJS.
            </p>

            <h3 id="using-foreign-object">Using foreignObject</h3>

            <p>
                In the following example, a <code>foreignObject</code> element is placed within our SVG tag. Note that when using HTML elements within
                <code>foreignObject</code>, it's mandatory to include the XHTML namespace on the outermost or root element. In this instance, that
                is our <code>div</code> element. This example creates a simple card-like SVG <code>rect</code> element where the user is easily able
                to select the text.
            </p>

            <pre><code>&lt;svg version="1.1" width="300" height="130" xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;style&gt;
        div.card__background {
            background-color: #131e29;
            height: 100%;
        }
        p.card__text {
            color: #F2F2F2;
            font: 16px sans-serif;
            padding: 10px;
            margin: 0;
        }
        rect.card { fill: url(#gradient); }
        .stop1 { stop-color: #ff5c69; }
        .stop2 { stop-color: #ff4252; }
        .stop3 { stop-color: #ed2637; }
    &lt;/style&gt;
    &lt;defs>
        &lt;linearGradient id="gradient"&gt;
            &lt;stop class="stop1" offset="0%" /&gt;
            &lt;stop class="stop2" offset="50%" /&gt;
            &lt;stop class="stop3" offset="100%" /&gt;
        &lt;/linearGradient&gt;
    &lt;/defs>
    &lt;rect x="20" y="20" width="180" height="100" class="card" /&gt;
    &lt;foreignObject x="26" y="26" width="168" height="88"&gt;
        &lt;div xmlns="http://www.w3.org/1999/xhtml" class="card__background"&gt;
            &lt;p class="card__text">Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/foreignObject&gt;
&lt;/svg&gt;
</code></pre>

        <p>
            The SVG markup above produces the following element:
        </p>

        <svg version="1.1" width="300" height="130" xmlns="http://www.w3.org/2000/svg">
            <style>
                div.card__background {
                    background-color: #131e29;
                    height: 100%;
                }
                p.card__text {
                    color: #F2F2F2;
                    font: 16px sans-serif;
                    padding: 10px;
                    margin: 0;
                }
                rect.card { fill: url(#gradient); }
                .stop1 { stop-color: #ff5c69; }
                .stop2 { stop-color: #ff4252; }
                .stop3 { stop-color: #ed2637; }                
            </style>
            <defs>
                <linearGradient id="gradient">
                    <stop class="stop1" offset="0%" />
                    <stop class="stop2" offset="50%" />
                    <stop class="stop3" offset="100%" />
                </linearGradient>
            </defs>
            <rect x="20" y="20" width="180" height="100" class="card" />
            <foreignObject x="26" y="26" width="168" height="88">
                <div xmlns="http://www.w3.org/1999/xhtml" class="card__background">
                    <p class="card__text">Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>
                </div>
            </foreignObject>
        </svg>

        <p>
            Now that we have a better understanding of what <code>foreignObject</code> is all about, how would we create 
            an equivalent example with JointJS? Using <code>foreignObject</code> with JointJS is much the same as creating any 
            <a href="/tutorial/custom-elements" target="_blank"><code>custom element</code></a> which you can see in the following
            code example.
        </p>

        <pre><code>const namespace = joint.shapes;

const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

const paper = new joint.dia.Paper({
    // paper options
    preventDefaultViewAction: false
});

const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            fill: {
                type: 'linearGradient',
                stops: [
                    { offset: 0, color: '#ff5c69' },
                    { offset: 0.5, color: '#ff4252' },
                    { offset: 1, color: '#ed2637' }
                ]
            }
        },
        foreignObject: {
            width: 'calc(w-12)',
            height: 'calc(h-12)',
            x: 6,
            y: 6
        }
    },
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'foreignObject',
            selector: 'foreignObject',
            children: [
                {
                    tagName: 'div',
                    namespaceURI: 'http://www.w3.org/1999/xhtml',
                    selector: 'background',
                    style: {
                        backgroundColor: '#131e29',
                        height: '100%'
                    },
                    children: [
                        {
                            tagName: 'p',
                            selector: 'text',
                            style: {
                                color: '#F2F2F2',
                                font: '16px sans-serif',
                                padding: '10px',
                                margin: 0,
                            },
                            textContent: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
                        }
                    ]
                }
            ]
        }
    ]
});

const card = new Card();
card.position(10, 10);
card.resize(180, 100);
card.addTo(graph);
</code></pre>

        <p>
            In order for our JointJS example to have the equivalent functionality as the first example, we need to make selecting text possible.
            To do that, we use the <code>paper</code>
            <a href="/docs/jointjs#dia.Paper.prototype.options.preventDefaultViewAction" target="_blank"><code>preventDefaultViewAction</code></a> 
            option which prevents the default action when a Cell is clicked.
        </p>

        <p>
            While <code>preventDefaultViewAction</code> handles clicking, we also need to allow the user to select text via CSS. As the default CSS 
            in JointJS sets the <code>user-select</code> property to <code>'none'</code>, we need to override this on our element.
            The <code>preventDefaultViewAction</code> option combined with the following CSS override enables users to select text in the same manner 
            as the vanilla SVG example from earlier. We can also adjust the <code>cursor</code> value in order to see the text cursor.
        </p>

        <pre><code>g[data-type="example.ForeignObject"] {
    -webkit-user-select: text;  /* prefix needed for Safari */
    user-select: text;
}

g[data-type="example.ForeignObject"] p {
    cursor: auto;
}
</code></pre>

        <p>
            You'll also notice that trying to select text by dragging results in the element moving. If you would like to prevent the element
            from entering <a href="/docs/jointjs#dia.Paper.prototype.options.interactive" target="_blank"><code>interactive</code></a> mode,
            therefore preventing the element from reacting to events in the default manner, you could take advantage of the
            <a href="/docs/jointjs#dia.CellView.prototype.preventDefaultInteraction" target="_blank"><code>preventDefaultInteraction</code></a>
            method.
        </p>

        <pre><code>paper.on('cell:pointerdown', (cellView, evt) => {
    cellView.preventDefaultInteraction(evt);
});
</code></pre>

        <p>
            Since our <code>foreignObject</code> contains quite a lot of HTML, we can take advantage of the 
            <a href="/docs/jointjs#util.svg" target="_blank"><code>util.svg</code></a> method to make our 
            <a href="/docs/jointjs#dia.Cell.markup" target="_blank""><code>markup</code></a> object more concise. 
            The resulting custom element definition will be more compact, and might prove easier to read for some developers.
        </p>

        <pre><code>const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            fill: {
                type: 'linearGradient',
                stops: [
                    { offset: 0, color: '#ff5c69' },
                    { offset: 0.5, color: '#ff4252' },
                    { offset: 1, color: '#ed2637' }
                ]
            }
        },
        foreignObject: {
            width: 'calc(w-12)',
            height: 'calc(h-12)',
            x: 6,
            y: 6
        }
    },
}, {
    // The /* xml */ comment is optional.
    // It is used to tell the IDE that the markup is XML.
    markup: joint.util.svg/* xml */`
        &lt;rect @selector="body"/&gt;
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div
                xmlns="http://www.w3.org/1999/xhtml"
                style="background-color: #131e29; height: 100%;"
            &gt;
                &lt;p style="color: #F2F2F2; font: 16px sans-serif; padding: 10px; margin: 0;"&gt;
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <h3 id="interactive-example">A more interactive example</h3>

        <p>
            One alternative method which diagram libraries utilize to allow users work with HTML is to render HTML on top of an underlying element.
            While this approach can be successful, it comes with a lot of additional complexity such as the need to keep dimensions and position 
            of the HTML in sync with the element itself. To this day,
            this approach is used by many competing diagram libraries - especially those that use HTML
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" target="_blank">Canvas</a> rendering.
        </p>

        <p>
            It's possible to use the HTML overlay approach in JointJS, however since JointJS primarily works with SVG - and SVG was designed to work 
            well with other web standards such as HTML - taking advantage of <code>foreignObject</code> can allow users of JointJS create HTML-rich 
            elements while avoiding some of the difficulties of other approaches.
        </p>

        <p>
            Creating a static card-like element was a gentle introduction to working with <code>foreignObject</code>.
            For a more realistic example,
            let's try to create a custom <code>form</code> element with several interactive
            controls.
        </p>

        <p>
            In our previous example, we created an SVG <code>rect</code> element alongside our <code>foreignObject</code>. If your shape requires
            other SVG elements, it's possible to add them in the same manner, but it's also not a requirement. You may find that 
            <code>foreignObject</code> is sufficient, and it's the only SVG element you wish to define explicitly. In our <code>form</code>
            example, that's exactly the route we will take, and you can see it demonstrated in the following code example.
        </p>

        <pre><code>const Form = joint.dia.Element.define('example.Form', {
    attrs: {
        foreignObject: {
            width: 'calc(w)',
            height: 'calc(h)'
        }
    }
}, {
    markup: joint.util.svg/* xml */`
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div
                xmlns="http://www.w3.org/1999/xhtml"
                class="outer"
            &gt;
                &lt;div class="inner"&gt;
                    &lt;form class="form"&gt;
                        &lt;input @selector="name" type="text" name="name" autocomplete="off" placeholder="Your diagram name"/&gt;
                        &lt;button>
                            &lt;span&gt;Submit&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <p>
            As the default styles for our <code>form</code> are a little boring, we will also add the following CSS just to make our elements a 
            little more presentable. It's also possible to add CSS via an SVG 
            <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/style" target="_blank"><code>style</code></a> element, or inline 
            styles via the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/style" target="_blank">style</a> attribute 
            if you prefer, but as we are adding a substantial amount of CSS, we will use a separate stylesheet.
        </p>

        <pre><code>.outer {
    background: linear-gradient(92.05deg, hsl(355, 100%, 68%) 12.09%, hsl(355, 100%, 63%) 42.58%, hsl(355, 85%, 54%) 84.96%);
    padding: 6px;
    width: 100%;
    height: 100%;
}

.inner {
    background-color: hsl(210, 37%, 14%);
    width: 100%;
    height: 100%;
}

.form {
    display: flex;
    font-family: sans-serif;
    flex-direction: column;
    justify-content: space-evenly;
    padding: 0 32px;
    width: 100%;
    height: 100%;
}

input {
    all: unset;
    background: hsl(218, 80%, 2%);
    color: white;
    cursor: text;
    font-size: 1rem;
    height: 56px; 
    outline-color: hsl(355, 100%, 63%);
    outline-width: thin;
    padding: 0 32px;
}

input::placeholder {
    color: hsl(0, 0%, 50%);
}

input:focus-visible {
    outline-style: inset;
}

button {
    background-color: hsl(218, 80%, 2%);
    border: unset;
    cursor: pointer;
    font-family: sans-serif;
    font-size: 1rem;
    font-weight: 600;
    height: 56px;
    outline-color: hsl(355, 100%, 63%);
    outline-width: thin;
}

button:focus-visible {
    outline-style: inset;
}

button span {
    background: linear-gradient(92.05deg, hsl(355, 100%, 68%) 12.09%, hsl(355, 100%, 63%) 42.58%, hsl(355, 85%, 54%) 84.96%);
    -webkit-background-clip: text;
    background-clip: text; 
    -webkit-text-fill-color: hsl(0deg 0% 0% / 0%);
    font-size: 1.2rem;
}
</code></pre>

        <div class="paper" id="paper-foreign-object-prevent-default"></div>
        <p>JointJS source code: <a href="js/foreign-object.js" target="_blank">foreign-object.js</a></p>

        <p>
            When working with JointJS, you will have to make decisions about how some HTML elements lose focus. Notably, the default behavior of an 
            HTML <code>form</code> is that when a user clicks on a blank area, the active input field loses focus. In order to mimic 
            this behaviour in JointJS, we can create an event to remove focus when the user clicks on a blank <code>paper</code> area, or even on
            any JointJS element.
        </p>

        <pre><code>paper.on('blank:pointerdown cell:pointerdown', () => {
    document.activeElement.blur();
});
</code></pre>

        <p>
            Alternatively, setting the 
            <a href="/docs/jointjs#dia.Paper.prototype.options.preventDefaultViewAction" target="_blank"><code>preventDefaultViewAction</code></a>
            and 
            <a href="/docs/jointjs#dia.Paper.prototype.options.preventDefaultBlankAction" target="_blank"><code>preventDefaultBlankAction</code></a> 
            <code>paper</code> options to <code>false</code> would have the same effect on focus.
        </p>

        <h3 id="preventing-default-jointjs-browser-behaviour">Preventing default JointJS and browser behaviour</h3>

        <p>
            Earlier, we mentioned that we prevented the default action when a Cell is clicked by using <code>preventDefaultViewAction</code>.
            You may be asking yourself, why don't we need to use the <code>preventDefaultViewAction</code> <code>paper</code> option for this example?
        </p>

        <p>
            The simple explanation is that JointJS prevents its own default interactions when working with HTML form controls. That means for example,
            if you try to drag an <code>input</code>, the element doesn't move as a whole, but it selects the text inside the input. The elements 
            where JointJS prevents its default interaction are as follows:
        </p>

        <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea" target="_blank"><code>textarea</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input" target="_blank"><code>input</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" target="_blank"><code>button</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select" target="_blank"><code>select</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option" target="_blank"><code>option</code></a></li>
        </ul>

        <p>
            In the example above, we created a <code>paper</code> event with the aim of managing focus. One detail you may not have noticed is that the 
            <code>button</code> text is actually contained within a <code>span</code> element. If we had not applied the <code>paper</code> event, 
            and the <code>input</code> was in focus, clicking on the <code>span</code> element won't actually cause the <code>input</code> to lose focus. 
            However, clicking on the <code>button</code> itself will make the <code>input</code> lose focus, as <code>button</code> is one of the 
            elements where JointJS prevents its default interaction.
        </p>

        <p>
            If we wanted the <code>input</code> to lose focus when a user clicks on the <code>span</code> element, utilizing the 
            <code>preventDefaultViewAction</code> option would accomplish this. A stronger measure would be to use the <code>paper</code>
            <a href="/docs/jointjs#dia.Paper.prototype.options.guard" target="_blank"><code>guard</code></a> option as follows
            <code>guard: (evt) => ['SPAN'].includes(evt.target.tagName)</code>. When using this option, it's important to note that
            events are not propagated to the paper, so events such as <code>'element:pointerdown'</code> would not be triggered when a user
            clicks on the <code>span</code> element. However, including both of these options to manage focus in this instance would be superfluous
            if the <code>paper</code> event is already applied.
        </p>

        <p>
            One of the final items you may wish to take care of when using a <code>form</code> in JointJS is to prevent the default browser behaviour 
            when submitting user data. In order to achieve this, we will create a custom 
            <a href="/docs/jointjs#dia.CellView.custom" target="_blank"><code>CellView</code></a> for our element. It will contain an events hash 
            which specifies a DOM event that will be bound to a method on the view. The <i>key</i> is made up of the event name plus a CSS selector, 
            and the <i>value</i> is a method on our custom view.
        </p>

        <p>
            In the following example, we specify the event name <code>'submit'</code>, plus our CSS element selector <code>'form'</code>, and lastly 
            the name of our method <code>'onSubmit'</code>. We can prevent that browser refresh by using <code>evt.preventDefault()</code>, and clear 
            the value of the HTML input value afterwards if we wish to do so.
        </p>

        <pre><code>joint.shapes.example.FormView = joint.dia.ElementView.extend({

    events: {
        'submit form': 'onSubmit',
        'change input': 'onChange'
    },

    onSubmit: function(evt) {
        evt.preventDefault();
        this.model.attr('name/props/value', '');
    },

    onChange: function(evt) {
        // Set the value property which is accessible from the model
        this.model.attr('name/props/value', evt.target.value);
    }
});
</code></pre>

        <h3 id="props">Props, a special attribute</h3>

        <p>
            The last point which we would like to cover when discussing HTML form controls is the special 
            <a href="/docs/jointjs#dia.attributes.props" target="_blank"><code>props</code></a> attribute. When creating HTML elements, it's
            possible to define various attributes to initialize certain DOM properties. In some cases (such as <code>'id'</code>), 
            this is a one-to-one relationship, but in others (such as <code>'value'</code>), the attribute doesn't reflect the property, and it
            serves more like an initial and current state.
            When working with JointJS, it wouldn't make sense that users can only set an initial <code>'value'</code> attribute for an 
            <code>input</code>, and then have to access DOM elements themselves to update the <code>'value'</code> property. If using 
            <code>foreignObject</code>, users should be able to set the current <code>'value'</code> of an <code>input</code> through the model at 
            any time they want. It's for this exact reason that we created the special <code>props</code> attribute, and it can be utilized as 
            follows:
        </p>

        <pre><code>// Example markup using the value attribute (initial value of input)
&lt;input @selector="example" type="text" value="initial" /&gt;

...

// Set the value property which is accessible from the model (current value of input)
element.attr('example/props/value', 'current');

...

// For illustration purposes - not required to access DOM elements in this manner
const input = document.querySelector('input');

// Expected values
console.log(input.value); // current (JointJS sets the 'value' DOM property internally)
console.log(input.defaultValue); // initial
console.log(input.getAttribute('value')); // initial
</code></pre>

        <p>
            The supported properties when using the <code>props</code> attribute are:
        </p>

        <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#checked" target="_blank"><code>checked</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#attributes" target="_blank"><code>selected</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#disabled" target="_blank"><code>disabled</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#readonly" target="_blank"><code>readOnly</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable" target="_blank"><code>contentEditable</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#value" target="_blank"><code>value</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes" target="_blank"><code>indeterminate</code></a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#attributes" target="_blank"><code>multiple</code></a></li>
        </ul>

        <br>

        <h3 id="caveats">Caveats!</h3>

        <p>
            While all that we have covered so far is great for users of JointJS, even in this day and age, it's not without some caveats.
            Firstly, we will cover some minor points regarding syntax that you should be aware of when using HTML within your <code>markup</code>.
            Afterwards, we'll look at some browser related quirks which mostly centre around Safari.
        </p>


        <h4 id="syntax">Syntax</h4>


        <h5 id="boolean-attributes" style="font-weight: normal; font-size: 1rem;">Boolean Attributes</h5>

        <p>
            Boolean attributes are those data types where the presence or absence of the attribute represents its <i>truthy</i> or <i>falsy</i>
            value respectively. Some common examples are 
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required" target="_blank"> 
            <code>required</code></a>, 
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled" target="_blank"><code>disabled</code></a>, 
            and <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly" target="_blank"><code>readonly</code></a>.
        </p>

        <p>
            Usually, boolean attributes can be utilized in 3 different ways: you can omit the value, use an empty string, or set the value as a
            case-insensitive match for the attribute's name. In our case, we cannot omit the value, so we must use the 2nd or 3rd option. This is 
            demonstrated in the following example which uses the <code>required</code> attribute.
        </p>

        <pre><code>// Omitted value will throw error ❌
&lt;input @selector="name" type="text" id="name" name="name" required /&gt;

// Use an empty string ✅
&lt;input @selector="name" type="text" id="name" name="name" required="" /&gt;

// Use a case-insensitive match for the attribute's name ✅
&lt;input @selector="name" type="text" id="name" name="name" required="required" /&gt;
</code></pre>

        <h5 id="closing-tags" style="font-weight: normal; font-size: 1rem;">Closing Tags</h5>

        <p>
            In the past, developers traditionally used start and end tags for HTML elements. If we wanted some text on the page, we might 
            create the following paragraph element <code>&lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;</code>. With the advent 
            of HTML5, it's not strictly necessary to close certain elements which are considered 
            <a href="https://developer.mozilla.org/en-US/docs/Glossary/Void_element" target="_blank">void</a>, i.e., elements which can't have 
            child nodes.
        </p>

        <p>
            In HTML, it's possible to write a line-break element as <code>&lt;br&gt;</code> or <code>&lt;br /&gt;</code>. The trailing slash
            in the tag has no meaning, and browsers simply ignore it. However, in XML, XHTML, and SVG, self closing tags are required in void elements, 
            so a trailing slash is necessary. When working with tagged templates in JointJS, you must use a trailing slash. This can be 
            observed in the following example:
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="font-family: sans-serif;"
    &gt;
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
        &lt;br&gt; // line-break element without trailing slash will throw an error ❌
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;

...

// Use a trailing slash ✅
&lt;br/&gt;
</code></pre>

        <h5 id="html-entities" style="font-weight: normal; font-size: 1rem;">HTML Entities</h5>

        <p>
            HTML Entities are used in place of some characters that are reserved depending on the language. For example,
            the greater than (>) or less than (<) sign cannot be used in HTML as it would cause a conflict with tags.
            This is also one area to be careful with when using tagged templates. You must use the entity number rather than
            the entity name. Entity numbers are the ones which use the # symbol. That means using <code>&amp;#169;</code> 
            is preferable over <code>&amp;copy;</code>.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content" xmlns="http://www.w3.org/1999/xhtml"&gt;
        &amp;copy; // copy HTML entity name will throw an error ❌
    &lt;/div&gt;
&lt;/foreignObject&gt;

...

// Use an entity number ✅
&amp;#169;
</code></pre>

        <h5 id="ids" style="font-weight: normal; font-size: 1rem;">IDs</h5>

        <p>
            Since having more than one ID of the same value in the DOM is considered invalid according to the 
            <a href="https://html.spec.whatwg.org/multipage/dom.html#the-id-attribute" target="_blank" rel="noopener noreferrer">HTML</a>
            specification, we recommend not including an ID attribute in your HTML Elements. The first scenario where this may be relevant is when 
            choosing CSS selectors. Using a class attribute in your <code>markup</code> rather than an ID is advised.
        </p>

        <p>
            The second situation where this proves important is programmatically associating a <code>label</code> with an 
            <code>input</code> element. One method of making this association is by providing an <code>'id'</code> attribute to an <code>input</code>,
            and a <code>'for'</code> attribute to its <code>label</code>. Each of which would have the same value. This has
            a number of advantages such as screen readers reading the label when the associated input is focused, and also that the focus is 
            passed to the input when the associated label is clicked.
        </p>

        <p>
            As we don't want to use an ID, we should use an alternative method to make this association such as nesting an <code>input</code> in its 
            respective <code>label</code> which will have the same effect.
        </p>

        <pre><code>// Do not use ID attributes in HTML markup ❌
&lt;p id="paragraph"&gt; 
    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
&lt;/p&gt;

// Use a class attribute instead ✅
&lt;p class="paragraph"&gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
&lt;/p&gt;

...

// Do not use IDs for associating inputs and labels ❌
&lt;label>First Name&lt;/label&gt;
&lt;input @selector="firstname" type="text"/&gt;

// Use nesting to make this association instead ✅
&lt;label>First Name
    &lt;input @selector="firstname" type="text"/&gt;
&lt;/label&gt;
</code></pre>
        
        <h4 id="browser-related-quirks">Browser related quirks</h4>

        <p>
            At the beginning of this tutorial, we mentioned how <code>foreignObject</code> is fully supported in all browsers.
            Unfortunately, some inconsistencies do exist, and some unexpected behavior may occur.
        </p>

        <p>
            Our experience with both Chrome and Firefox has been very positive, but we have ran into some quirks when using Safari. 
            In this section, we will cover some issues we discovered, and some related 
            <a href="https://bugs.webkit.org/query.cgi" target="_blank">webkit</a> bugs, but this also isn't an exhaustive list, so you 
            might run into an issue with Safari that isn't mentioned here.
        </p>

        <p>
            The first issue arose when we tried to add an HTML5 <code>video</code> element to a shape. While this went as expected
            with Chrome and Firefox, the video seemed to be rendered in an incorrect position on Safari. After searching for a solution,
            we stumbled on the following <a href="https://bugs.webkit.org/show_bug.cgi?id=23113" target="_blank">webkit bug</a>.
        </p>

        <p>
            Upon reading, we couldn't help but notice others suggesting that properties like <code>opacity</code>, or <code>transform</code>
            were also causing issues for Safari users, so we added those styles to our elements, and sure enough, we saw similar results.
            HTML elements which had <code>opacity</code> or <code>transform</code> applied were also in the incorrect position.
        </p>

        <p>
            Naturally, we also searched the same bug report for any potential solutions, and found suggestions that adding a style of
            <code>'position: fixed'</code> to the outermost <code>div</code> element fixed some of the issues that people had. Once again,
            the information proved to be helpful, and the elements seemed to be positioned correctly again. We did notice when transforming the
            JointJS <code>paper</code> with a method such as 
            <a href="/docs/jointjs#dia.Paper.prototype.transformToFitContent" target="_blank"><code>transformToFitContent</code></a>, 
            <code>'position:fixed'</code> again caused issues with element position. Therefore, if you are using <code>paper</code> transforms, 
            the default <code>'position:static'</code> might be preferable
            for some use cases.
        </p>

        <p>
            On further inspection, we realized that we still had one major issue with the video. After dragging our JointJS shape, the video
            was still rendered in the incorrect position which was disappointing. The silver lining was that the <code>opacity</code> and 
            <code>transform</code> applied to our <code>label</code> and <code>input</code> respectively were working correctly, and those 
            elements seemed to maintain the correct position. The following is some example <code>markup</code> we had issues with in Safari. 
            Your mileage may vary.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="position: fixed; font-family: sans-serif;"
    &gt;
        &lt;span style="opacity: 0.5">First Name&lt;/span&gt;
        &lt;input @selector="firstname" type="text" style="transform: translateX(10px); width: 100%;"/&gt;
        &lt;span>Last Name&lt;/span>
        &lt;input @selector="lastname" type="text" style="width: 100%;"/&gt;
        &lt;span>Video&lt;/span>
        &lt;video @selector="video" controls="controls" width="200"&gt;
            &lt;source src="path_to_your_example_video.mp4" type="video/mp4" /&gt;
        &lt;/video&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>

        <p>
            The situation described above, and the resulting issues were discovered mostly through trial and error. That's all well and good, but
            can we learn anything from the webkit bug reports? It seems that when HTML inside a <code>foreignObject</code> gets a 
            RenderLayer, the hierarchial position of the RenderLayer is inaccurate which results in the HTML being positioned incorrectly. 
            Let's try to reduce this information to some more actionable points.
        </p>

        <p>Use of the following two properties in Safari should be approached with caution:</p>

        <ul>
            <li><code>transform</code></li>
            <li><code>opacity</code></li>
        </ul>

        <p>
            Regarding HTML elements themselves, we've already discovered that users should be wary of
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" target="_blank"><code>video</code></a> elements, and if they
            are positioned correctly. Are there any other elements to be careful with? Unfortunately, Yes! Enter the
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select" target="_blank"><code>select</code></a> element.
        </p>

        <p>
            If you've never tested which events are triggered when a user clicks on a <code>select</code> element, don't worry, we've done it, so 
            you don't have to. It turns out, the events that get triggered are quite inconsistent across all major browsers when interacting with 
            <code>select</code>. Safari, for example, only triggers <code>'pointerdown'</code> when you open <code>select</code>. As a result of these
            inconsistencies, JointJS includes <code>select</code> in the <code>paper</code> <code>guard</code> option by default. Therefore, if you 
            interact with a <code>select</code> element, JointJS will not trigger its <code>paper</code> events. You as a user are not obliged to do
            something about this, but it's something you should be aware of.
        </p>

        <p>
            One last delightful quirk of working with <code>select</code> in Safari is that when <code>multiple</code> is set to <code>'true'</code>,
            Safari does not allow you to select an <code>option</code> with a mouse, but does however allow selection via keyboard navigation.
        </p>

        <p>HTML Elements which show inconsistency in Safari are as follows:</p>

        <ul>
            <li><code>video</code></li>
            <li><code>select</code></li>
        </ul>
        
        <p>
            As stated already, this isn't an exhaustive list of issues, so it's possible you may run into some other inconsistencies with Safari.
            It's unfortunate that Safari still lags behind other modern browsers in relation to <code>foreignObject</code>, but there are also 
            reasons to be positive. One reason to have a brighter outlook is that some of the major issues we experienced here are currently being 
            worked on according to this <a href="https://bugs.webkit.org/show_bug.cgi?id=90738" target="_blank">bug</a> report, so hopefully in the 
            not too distant future, the majority of these issues will cease to exist.
        </p>

        <p>
            This is a section we would like to keep updated as much as possible, so if you encounter any other interesting behaviour, you can let us 
            know.
        </p>

        <h3 id="conclusion">Conclusion</h3>

        <p>
            We are very happy that we can now confidently recommend the use of <code>foreignObject</code> to users of JointJS, and that it's
            well-supported in all major browsers. We consider it a big step forward for creating diagrams with JointJS, and believe it will 
            allow the creation of even more innovative and interactive diagramming solutions. If you want to start using HTML with JointJS, there
            is no better time to do so, and we can't wait to see what you create.
        </p>

        <p>
            That's all we will cover in this tutorial. Thanks for staying with us if you got this far. If you would like 
            to explore any of the features mentioned here in more detail, you can find extra information in our 
            <a href="/docs/jointjs" target="_blank">JointJS documentation</a>.
        </p>

        <script src="../node_modules/prismjs/prism.js"></script>

        <script src="js/foreign-object.js"></script>
    </body>
</html>

