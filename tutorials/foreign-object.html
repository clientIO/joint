<!DOCTYPE html>
<html lang="en">
    <head>

        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prism-themes/themes/prism-one-light.css">

        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>


        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <link rel="stylesheet" href="css/foreign-object.css">
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>
    </head>
    <body class="language-javascript tutorial-page">


        <div id="foreign-object" class="tutorial">

            <h1>Foreign Object</h1>

            <p>
                In the wonderful world of SVG elements, 
                <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject" target="_blank"><code>foreignObject</code></a> 
                stands out from the rest as it provides some unique behaviour that other SVG elements do not. SVG, like other XML dialects, is
                namespaced. That means if you want to include elements from a different XML namespace right in your SVG, you need some
                mechanism to enable this functionality. That's where <code>foreignObject</code> comes into play.
            </p>

            <p>
                How does this relate to creating diagrams with JointJS? While JointJS provides a lot of functionality and customization
                for users, we as developers are a habitual bunch. If we want to create some basic interactive elements, we often want to
                reach for technologies we are already familiar with, and in web land, the dominant force in this regard is still good old HTML.
            </p>

            <p>
                Historically, recommending <code>foreignObject</code> to users of JointJS was a little bit tricky, the main reason for this was the
                inherent lack of support for <code>foreignObject</code> in Internet Explorer. Due to the necessity of supporting all our users,
                including those who were still using IE, there was a hesitancy about integrating support into the library fully. Luckily for us, 
                the days in which we had to support IE are now at an end, and all other major browsers have full support which can be
                seen in the following <a href="https://caniuse.com/?search=foreignObject" target="_blank">caniuse</a> reference table.
            </p>

            <p>
                Now that we can more confidently recommend the use of <code>foreignObject</code> with JointJS, users can now enjoy the benefits of
                HTML in their diagrams. Embedding HTML text in SVG, creating basic interactive elements like buttons, or working
                with HTML inputs should now be a more straightforward process. With this addition, combining the power of JointJS 
                with <code>foreignObject</code> opens up a world of possibilities for interactivity within your JointJS diagrams.
            </p>

            <p>
                In order to get a general idea of how <code>foreignObject</code> can be utilized in SVG, let's start with a simple 
                example without using JointJS.
            </p>

            <h3>Using foreignObject</h3>

            <p>
                In the following example, a <code>foreignObject</code> element is placed within our SVG tag. When using HTML elements within
                <code>foreignObject</code>, note, that it's mandatory to include the XHTML namespace on the outermost or root element. In 
                this instance, that is our <code>div</code> element. This example creates a simple card-like SVG <code>rect</code>
                element where the user is easily able to select the text.
            </p>

            <pre><code>&lt;svg version="1.1" width="300" height="110" xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;style&gt;
        foreignObject p.text {
            color: white;
            font: 16px sans-serif;
            margin: 0;
        }
    &lt;/style&gt;
    &lt;rect x="0", width="180" height="100" rx="5" ry="5" fill="#4b5d67" /&gt;
    &lt;foreignObject x="10" y="10" width="160" height="80"&gt;
        &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
            &lt;p style="padding: 5px" class="text">Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/foreignObject&gt;
&lt;/svg&gt;
</code></pre>

        <p>
            The SVG markup above produces the following element:
        </p>

        <svg version="1.1" width="300" height="110" xmlns="http://www.w3.org/2000/svg">
            <style>
                foreignObject p.text {
                    color: white;
                    font: 16px sans-serif;
                    margin: 0;
                }
            </style>
            <rect x="0", width="180" height="100" rx="5" ry="5" fill="#4b5d67" />
            <foreignObject x="10" y="10" width="160" height="80">
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <p style="padding: 5px" class="text">Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>
                </div>
            </foreignObject>
        </svg>

        <p>
            Now that we have a better understanding of what <code>foreignObject</code> is all about, how would we create 
            an equivalent example with JointJS? Using <code>foreignObject</code> with JointJS is much the same as creating any 
            <a href="/tutorial/custom-elements" target="_blank"><code>custom element</code></a> which you can see in the following
            code example.
        </p>

        <pre><code>const namespace = joint.shapes;

const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

const paper = new joint.dia.Paper({
    // paper options
    guard: (evt) => ['P'].includes(evt.target.tagName)
});

const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#4b5d67',
            fill: '#4b5d67',
            strokeWidth: 1,
            rx: 5,
            ry: 5
        },
        foreignObject: {
            width: 'calc(w-20)',
            height: 'calc(h-20)',
            x: 10,
            y: 10
        }
    },
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'foreignObject',
            selector: 'foreignObject',
            children: [
                {
                    tagName: 'div',
                    namespaceURI: 'http://www.w3.org/1999/xhtml',
                    selector: 'content',
                    style: {
                        fontFamily: 'sans-serif',
                        fontSize: 16,
                        color: 'white'
                    },
                    children: [
                        {
                            tagName: 'p',
                            selector: 'textContent',
                            style: {
                                padding: 5,
                                margin: 0
                            },
                            textContent: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
                        }
                    ]
                }
            ]
        }
    ]
});

joint.shapes.example.ForeignObjectView = joint.dia.ElementView.extend();

const card = new Card({
    position: { x: 10, y: 10 },
    attrs: {
        body: { width: 180, height: 100 }
    }
});

card.addTo(graph);
</code></pre>

        <p>
            As mentioned earlier, we would like to create an equivalent example with JointJS, that means selecting text needs
            to be possible. In order to achieve this functionality, we need to use the <code>paper</code>
            <a href="/docs/jointjs#dia.Paper.prototype.options.guard" target="_blank"><code>guard</code></a> option available
            in JointJS to prevent the <code>paper</code> from handling UI events related to <code>&lt;p&gt;</code>
            tags. In our <code>guard</code> function, we can return <code>true</code> if the <code>evt.target.tagName</code> 
            is <code>'P'</code>.
        </p>

        <p>
            While <code>guard</code> will handle events, we also need to allow the user select text via CSS. As the default CSS 
            in JointJS sets the <code>user-select</code> property to <code>'none'</code>, we need to override this on our element.
            The <code>guard</code> option combined the with following CSS override enables users to select text in the same manner 
            as the vanilla SVG example from earlier. We can also adjust the <code>cursor</code> value in order to see the text cursor.
        </p>

        <pre><code>g[data-type="example.ForeignObject"] {
    -webkit-user-select: text;  /* prefix needed for Safari */
    user-select: text;
}

g[data-type="example.ForeignObject"] p {
    cursor: auto;
}
</code></pre>

        <p>
            As our <code>foreignObject</code> might contain lots of HTML, there are moments when we certainly want to
            be more concise when creating custom elements. Taking advantage of
            <a href="/docs/jointjs#util.svg" target="_blank"><code>util.svg</code></a> in JointJS,
            we can convert a string into a <a href="/docs/jointjs#dia.Cell.markup" target="_blank""><code>markup</code></a>
            object while declaring a <code>Cell</code>. The resulting custom element will be more compact, and maybe easier to
            read for some users.
        </p>

        <pre><code>const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#4b5d67',
            fill: '#4b5d67',
            strokeWidth: 1,
            rx: 5,
            ry: 5
        },
        foreignObject: {
            width: 'calc(w-20)',
            height: 'calc(h-20)',
            x: 10,
            y: 10
        }
    },
}, {
    // The /* xml */ comment is optional.
    // It is used to tell the IDE that the markup is XML.
    markup: joint.util.svg/* xml */`
        &lt;rect @selector="body"/&gt;
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div @selector="content"
                    xmlns="http://www.w3.org/1999/xhtml"
                    style="font-family: sans-serif; font-size: 16px; color: white;"
            &gt;
                &lt;p @selector="textContent"
                    style="margin: 0; padding: 5px"
                &gt;
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <h3>A more interactive example</h3>

        <p>
            One typical method which diagram libraries utilize to allow users work with HTML is to render HTML on top of an underlying element.
            While this approach can be successful, it comes with a lot of additional complexity such as the need to keep dimensions and position 
            of the HTML in sync with the element itself which isn't ideal. It's possible to use this approach with JointJS, and still to this day,
            this is how many diagram libraries provide this functionality, especially if they use
            HTML <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" target="_blank">canvas</a>.
        </p>

        <p>
            As JointJS primarily works with SVG, and SVG was designed to work well with other web standards such as HTML, taking advantage of
            <code>foreignObject</code> can allow users of JointJS create HTML-rich elements while avoiding some of the difficulties of other 
            approaches.
        </p>

        <p>
            Creating a static card-like element was a gentle introduction to working with <code>foreignObject</code>, but if we are being realistic,
            a lot of users will most likely want to work with more interactive elements. One of the most common interactive controls on the web is 
            the <code>form</code>, so let's try to create a custom element which allows the user to submit some data.
        </p>

        <p>
            In our previous example, we created an SVG <code>rect</code> element alongside our <code>foreignObject</code>. If your shape requires
            other SVG elements, it's possible to add them in the same manner, but it's also not a requirement. You may find that 
            <code>foreignObject</code> is sufficient, and it's the only SVG element you wish to define explicitly. In our <code>form</code>
            example, that's exactly the route will take, and you can see it demonstrated in the following code example.
        </p>

        <pre><code>const Form = joint.dia.Element.define('example.Form', {
    attrs: {
        foreignObject: {
            width: 'calc(w)',
            height: 'calc(h)'
        }
    }
}, {
    markup: joint.util.svg/* xml */`
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div @selector="content"
                xmlns="http://www.w3.org/1999/xhtml"
                style="font-family: sans-serif;"
            &gt;
                &lt;form @selector="formContent" id="form"&gt;
                    &lt;label @selector="label" for="diagramName">Name&gt;/label&gt;
                    &lt;input @selector="diagramName" type="text" id="diagramName" name="diagramName"/&gt;
                    &lt;input @selector="submit" type="submit" value="submit"/&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <p>
            Just to make our form a little more presentable, we will also add the following CSS.
        </p>

        <pre><code>g[data-type="example.Form"] {
    filter: drop-shadow(0.35rem 0.35rem 0.4rem rgba(0, 0, 0, 0.5));
}

form {
    font-size: 16px;
    margin: 1.2rem;
}

label {
    color: darkslategray;
    display: inline-block;
    font-size: 12px;
    margin-bottom: 0.4rem;
}

input {
    box-sizing: border-box;
    font-size: inherit;
    margin-bottom: 0.8rem;
    width: 100%;
}
</code></pre>

        <div class="paper" id="paper-foreign-object-prevent-default"></div>

        <p>
            The joy of working with <code>foreignObject</code> in our shapes is that we still get to take advantage of some neat functionality such
            as clicking on a <code>label</code> element, and the related <code>input</code> will be focused. In our case, the <code>label</code> has
            the attribute <code></code> which corresponds to the <code>input</code> with the same <code>'id'</code> attribute.
        </p>

        <p>
            We will however need to remove focus when the user clicks on a blank <code>paper</code> area, or on another element. We can do this with
            the following event:
        </p>

        <pre><code>paper.on('blank:pointerdown cell:pointerdown', () => {
    document.activeElement.blur();
});
</code></pre>

        <p>
            Once again, as we want to prevent the <code>paper</code> from handling browser UI events relating to our <code>input</code>,
            we can include it in the paper <code>guard</code> option. Now, we can type normally in our <code>input</code>.
        </p>

        <pre><code>// paper option
guard: (evt) => ['INPUT'].includes(evt.target.tagName)
</code></pre>

        <p>
            At this stage, we have handled most of the functionality related to our events. When using a form, you might want to prevent the default 
            browser behaviour when submitting user data. In order to prevent this behaviour, we will create a custom 
            <a href="/docs/jointjs#dia.CellView.custom" target="_blank"><code>CellView</code></a>. It will contain an events hash which specifies a 
            DOM event that will be bound to a method on the view. The <i>key</i> is made up of the event name plus a CSS selector, 
            and the <i>value</i> is a method on our custom view.
        </p>

        <p>
            In the following example, we specify the event name <code>'submit'</code>, plus our CSS element selector <code>'form'</code>, and lastly the 
            name of our method <code>'onSubmit'</code>. We prevent a browser refresh by using <code>evt.preventDefault()</code>, and clear the value of the
            HTML input value afterwards.
        </p>

        <pre><code>joint.shapes.example.FormView = joint.dia.ElementView.extend({

    events: {
        'submit form': 'onSubmit'
    },

    onSubmit: function(evt) {
        evt.preventDefault();
        evt.target.children.diagramName.value = ''; // remove input value after submit
    },

});
</code></pre>

        <!-- 
            Show example with CSS layouts, 3 elements (maybe in grid)
         -->

        <div class="paper" id="paper-foreign-object"></div>

        <p>
            preventDefault paper option
        </p>

        

        <!-- TODO
            - how to use
            - test specificity, inline vs stylesheet
            - syntax with curly brackets?
        -->

        <!-- <h3>CSS Styles</h3> -->

        <h3>Caveats!!!</h3>

        <p>
            While all that we have covered so far is great for users of JointJS, even in this day and age, it's not without some caveats.
            Firstly, we will cover some relatively minor caveats regarding syntax, and afterwards we'll look at some browser related quirks.
        </p>


        <h4>Syntax</h4>


        <p><i>Boolean Attributes</i></p>

        <p>
            Boolean attributes are those data types where the presence or absence of the attribute represents its <i>truthy</i> or <i>falsy</i>
            value respectively. Some common examples are <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required" target="_blank"> 
            <code>required</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled" target="_blank"><code>disabled</code></a>, 
            and <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly" target="_blank"><code>readonly</code></a>.
        </p>

        <p>
            Usually, boolean attributes can be utilized in 3 different ways, you can omit the value, use an empty string, or set the value as a
            case-insensitive match for the attribute's name. In our case, we cannot omit the value, so we must use the 2nd or 3rd option. This is 
            demonstrated in the following example which uses the <code>required</code> attribute.
        </p>

        <pre><code>// omitted value will throw error ❌
&lt;input @selector="name" type="text" id="name" name="name" required /&gt;

// use an empty string
&lt;input @selector="name" type="text" id="name" name="name" required="" /&gt;

// use a case-insensitive match for the attribute's name
&lt;input @selector="name" type="text" id="name" name="name" required="required" /&gt;
</code></pre>

        <p><i>Closing Tags</i></p>

        <p>
            In the past, developers traditionally used start and end tags for HTML elements. If we wanted some text on the page, we might 
            create the following paragraph element <code>&lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;</code>. With the advent 
            of HTML5, it's not strictly necessary to close certain elements which are considered 
            <a href="https://developer.mozilla.org/en-US/docs/Glossary/Void_element" target="_blank">void</a>, i.e., elements which can't have 
            child nodes.
        </p>

        <p>
            In HTML, it's possible to write a line-break element as <code>&lt;br&gt;</code> or <code>&lt;br /&gt;</code>. The trailing slash
            in the tag has no meaning, and browsers simply ignore it. However, in XML, XHTML, and SVG, self closing tags are required in void elements, 
            so a trailing slash is necessary. When working with tagged templates in JointJS, you must use a trailing slash. This can be 
            observed in the following example:
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="font-family: sans-serif;"
    &gt;
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
        &lt;br&gt; // line-break element without trailing slash will throw an error ❌
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>

        <p><i>HTML Entities</i></p>

        <p>
            HTML Entities are used in place of some characters that are reserved depending on the language. For example,
            the greater than (>) or less than (<) sign cannot be used in HTML as it would cause a conflict with tags.
            This is also one area to be careful with when using tagged templates. You must use the entity number rather than
            the entity name. Entity names are the ones which use the # symbol. That means using <code>&amp;#169;</code> 
            is preferable over <code>&amp;copy;</code>.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content" xmlns="http://www.w3.org/1999/xhtml"&gt;
        &amp;copy; // copy HTML entity name will throw an error ❌
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>
        
        <!-- TODO
            - foreignObject export in JointJS+
         -->


        <h4>Browser Related Quirks</h4>

        <p>
            At the beginning of this tutorial, we mentioned how <code>foreignObject</code> is fully supported in all browsers.
            Unfortunately, that doesn't mean some inconsistencies exist, or that some unexpected behaviour might occur. 
        </p>

        <p>
            Our experience with both Chrome and Firefox has been very positive, but we have ran into some quirks when using Safari. 
            In this section, we will cover some issues we discovered, and some related 
            <a href="https://bugs.webkit.org/query.cgi" target="_blank">webkit</a> bugs, but this also isn't an exhaustive list, so you 
            might run into an issue with Safari that isn't mentioned here.
        </p>

        <p>
            The first issue arose when we tried to add a HTML5 <code>video</code> element to our shape. While this went as expected
            with Chrome and Firefox, the video seemed to be rendered in an incorrect position on Safari. After searching for a solution,
            we stumbled on the following <a href="https://bugs.webkit.org/show_bug.cgi?id=23113" target="_blank">webkit bug</a>.
        </p>

        <p>
            Upon reading, we couldn't help but notice others suggesting that properties like <code>opacity</code>, or <code>transform</code>
            were also causing issues for Safari users, so we added some styles to our elements, and sure enough, we saw similar results.
            Elements which had both <code>opacity</code> or <code>transform</code> applied were also in the incorrect position.
        </p>

        <p>
            Naturally, we also search the same bug report for any potential solutions, and found reporting that adding a style of
            <code>'position: fixed'</code> to the outermost <code>div</code> element fixed some of the issued that people had. Once again,
            the information proved to be helpful, and the elements seemed to be positioned correctly again.
        </p>

        <p>
            Upon further inspection, we did realize, we still had one major issue with the video. After dragging our JointJS shape, the video
            was still rendered in the incorrect position after changing position which was disappointing. The silver lining is that the
            <code>opacity</code> and <code>transform</code> applied to our <code>label</code> and <code>input</code> was working correctly.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="position: fixed; font-family: sans-serif;"
    &gt;
        &lt;span style="opacity: 0.5">First Name&lt;/span&gt;
        &lt;input @selector="firstname" type="text" style="transform: translateX(10px); width: 100%;"/&gt;
        &lt;span>Last Name&lt;/span>
        &lt;input @selector="lastname" type="text" style="width: 100%;"/&gt;
        &lt;span>Video&lt;/span>
        &lt;video @selector="video" controls="controls" width="200"&gt;
            &lt;source src="path_to_video.mp4" type="video/mp4" /&gt;
        &lt;/video&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>

        <p>
            It's unfortunate that Safari still lags behind other modern browsers in relation to <code>foreignObject</code>, but there are also reasons to be positive.
            One reason to have a brighter outlook is that the issues we had here are currently being worked on according to this 
            <a href="https://bugs.webkit.org/show_bug.cgi?id=90738" target="_blank">bug</a> report, so hopefully in the not too distant future the majority of these issues
            will cease to exist.`
        </p>


        <!-- TODO
            Section on Caveats
            - safari issues with foreignObject, link to some bugs
        -->

        <!-- TODO
            - Workarounds for video - position: fixed;
            https://stackoverflow.com/questions/61895287/wrong-position-of-video-element-inside-svg-foreignobject-on-safari
            https://github.com/bkrem/react-d3-tree/issues/284
            - May be needed to remove use of opacity, elements with positioning, opacity, or transform seem to be affected.
            https://bugs.webkit.org/show_bug.cgi?id=23113
            - Select element even outside of foreignObject does not fire click event, pointerup.
            https://bugs.webkit.org/show_bug.cgi?id=239964
            https://bugs.webkit.org/show_bug.cgi?id=197612
         -->

         <!-- 
            when you open the <select> in:
            Chrome: it triggers pointerdown, pointerup, pointerclick as soon as its open
            Firefox: it triggers pointerdown on open and pointerup (and pointerclick only if you didn’t move) on close. But! If you open and then close by clickc somewhere else on the page, no other event is triggered.
            Safari: it triggers pointerdown on open. that’s it.
            There is another bug in Safari.
            <select multiple=“true”> does not allow you to select option with mouse (it works with keyboard)
          -->

          <!-- 
            position: static + overflow issue
           -->
        <h3>Conclusion</h3>

        <p>
            We believe <code>foreignObject</code> support is a big step forward for JointJS. It will allow our users to create 
            even more innovative and interactive diagramming solutions, and we can't wait to see what they create.
        </p>

        <script src="../node_modules/prismjs/prism.js"></script>

        <script src="js/foreign-object.js"></script>
        <script src="js/foreign-object-prevent-default.js"></script>
    </body>
</html>

