<!DOCTYPE html>
<html lang="en">
    <head>

        <meta name="description" content="Create interactive diagrams in JavaScript easily. JointJS plugins for ERD, Org chart, FSA, UML, PN, DEVS, LDM diagrams are ready to use." />

        <link rel="stylesheet" href="css/tutorial.css" />
        <link rel="stylesheet" href="../node_modules/prism-themes/themes/prism-one-light.css">

        <!-- Dependencies: -->
        <script src="../node_modules/jquery/dist/jquery.js"></script>
        <script src="../node_modules/lodash/lodash.js"></script>
        <script src="../node_modules/backbone/backbone.js"></script>


        <link rel="stylesheet" type="text/css" href="../build/joint.min.css" />
        <link rel="stylesheet" href="css/foreign-object.css">
        <script type="text/javascript" src="../build/joint.min.js"></script>

        <title>JointJS - JavaScript diagramming library - Getting started.</title>
    </head>
    <body class="language-javascript tutorial-page">


        <div id="foreign-object" class="tutorial">

            <h1>Foreign Object</h1>

            <p>
                In the wonderful world of SVG elements, 
                <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject" target="_blank"><code>foreignObject</code></a> 
                stands out from the rest as it provides some unique behaviour that other SVG elements do not. SVG, like other XML dialects, is
                namespaced. That means if you want to include elements from a different XML namespace right in your SVG, you need some
                mechanism to enable this functionality. That's where <code>foreignObject</code> comes into play.
            </p>

            <p>
                How does this relate to creating diagrams with JointJS? While JointJS provides a lot of functionality and customization
                for users, we as developers are a habitual bunch. If we want to create some basic interactive elements, we often want to
                reach for technologies we are already familiar with, and in web land, the dominant force in this regard is still good old HTML.
            </p>

            <p>
                Historically, recommending <code>foreignObject</code> to users of JointJS was a little bit tricky, the main reason for this was the
                inherent lack of support for <code>foreignObject</code> in Internet Explorer. Due to the necessity of supporting all our users,
                including those who were still using IE, there was a hesitancy about integrating support into the library fully. Luckily for us, 
                the days in which we had to support IE are now at an end, and all other major browsers have full support which can be
                seen in the following <a href="https://caniuse.com/?search=foreignObject" target="_blank">caniuse</a> reference table.
            </p>

            <p>
                Now that we can more confidently recommend the use of <code>foreignObject</code> with JointJS, users can now enjoy the benefits of
                HTML in their diagrams. Embedding HTML text in SVG, creating basic interactive elements like buttons, or working
                with HTML inputs should now be a more straightforward process. With this addition, combining the power of JointJS 
                with <code>foreignObject</code> opens up a world of possibilities for interactivity within your JointJS diagrams.
            </p>

            <p>
                In order to get a general idea of how <code>foreignObject</code> can be utilized in SVG, let's start with a simple 
                example without using JointJS.
            </p>

            <h3>Using foreignObject</h3>

            <p>
                In the following example, a <code>foreignObject</code> element is placed within our SVG tag. When using HTML elements within
                <code>foreignObject</code>, note, that it's mandatory to include the XHTML namespace on the outermost or root element. In 
                this instance, that is our <code>div</code> element. This example creates a simple card-like SVG <code>rect</code>
                element where the user is easily able to select the text.
            </p>

            <pre><code>&lt;svg version="1.1" width="300" height="110" xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;style&gt;
        foreignObject p.text {
            color: white;
            font: 16px sans-serif;
            margin: 0;
        }
    &lt;/style&gt;
    &lt;rect x="0", width="180" height="100" rx="5" ry="5" fill="#4b5d67" /&gt;
    &lt;foreignObject x="10" y="10" width="160" height="80"&gt;
        &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
            &lt;p style="padding: 5px" class="text">Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/foreignObject&gt;
&lt;/svg&gt;
</code></pre>

        <p>
            The SVG markup above produces the following element:
        </p>

        <svg version="1.1" width="300" height="110" xmlns="http://www.w3.org/2000/svg">
            <style>
                foreignObject p.text {
                    color: white;
                    font: 16px sans-serif;
                    margin: 0;
                }
            </style>
            <rect x="0", width="180" height="100" rx="5" ry="5" fill="#4b5d67" />
            <foreignObject x="10" y="10" width="160" height="80">
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <p style="padding: 5px" class="text">Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>
                </div>
            </foreignObject>
        </svg>

        <p>
            Now that we have a better understanding of what <code>foreignObject</code> is all about, how would we create 
            an equivalent example with JointJS? Using <code>foreignObject</code> with JointJS is much the same as creating any 
            <a href="/tutorial/custom-elements" target="_blank"><code>custom element</code></a> which you can see in the following
            code example.
        </p>

        <pre><code>const namespace = joint.shapes;

const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

const paper = new joint.dia.Paper({
    // paper options
    guard: (evt) => ['P'].includes(evt.target.tagName)
});

const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#4b5d67',
            fill: '#4b5d67',
            strokeWidth: 1,
            rx: 5,
            ry: 5
        },
        foreignObject: {
            width: 'calc(w-20)',
            height: 'calc(h-20)',
            x: 10,
            y: 10
        }
    },
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'foreignObject',
            selector: 'foreignObject',
            children: [
                {
                    tagName: 'div',
                    namespaceURI: 'http://www.w3.org/1999/xhtml',
                    selector: 'content',
                    style: {
                        fontFamily: 'sans-serif',
                        fontSize: 16,
                        color: 'white'
                    },
                    children: [
                        {
                            tagName: 'p',
                            selector: 'textContent',
                            style: {
                                padding: 5,
                                margin: 0
                            },
                            textContent: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
                        }
                    ]
                }
            ]
        }
    ]
});

joint.shapes.example.ForeignObjectView = joint.dia.ElementView.extend();

const card = new Card({
    position: { x: 10, y: 10 },
    attrs: {
        body: { width: 180, height: 100 }
    }
});

card.addTo(graph);
</code></pre>

        <p>
            As mentioned earlier, we would like to create an equivalent example with JointJS, that means selecting text needs
            to be possible. In order to achieve this functionality, we need to use the <code>paper</code>
            <a href="/docs/jointjs#dia.Paper.prototype.options.guard" target="_blank"><code>guard</code></a> option available
            in JointJS to prevent the <code>paper</code> from handling UI events related to <code>&lt;p&gt;</code>
            tags. In our <code>guard</code> function, we can return <code>true</code> if the <code>evt.target.tagName</code> 
            is <code>'P'</code>.
        </p>

        <p>
            While <code>guard</code> will handle events, we also need to allow the user select text via CSS. As the default CSS 
            in JointJS sets the <code>user-select</code> property to <code>'none'</code>, we need to override this on our element.
            The <code>guard</code> option combined the with following CSS override enables users to select text in the same manner 
            as the vanilla SVG example from earlier. We can also adjust the <code>cursor</code> value in order to see the text cursor.
        </p>

        <pre><code>g[data-type="example.ForeignObject"] {
    -webkit-user-select: text;  /* prefix needed for Safari */
    user-select: text;
}

g[data-type="example.ForeignObject"] p {
    cursor: auto;
}
</code></pre>

        <p>
            As our <code>foreignObject</code> might contain lots of HTML, there are moments when we certainly want to
            be more concise when creating custom elements. Taking advantage of
            <a href="/docs/jointjs#util.svg" target="_blank"><code>util.svg</code></a> in JointJS,
            we can convert a string into a <a href="/docs/jointjs#dia.Cell.markup" target="_blank""><code>markup</code></a>
            object while declaring a <code>Cell</code>. The resulting custom element will be more compact, and maybe easier to
            read for some users.
        </p>

        <pre><code>const Card = joint.dia.Element.define('example.ForeignObject', {
    attrs: {
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#4b5d67',
            fill: '#4b5d67',
            strokeWidth: 1,
            rx: 5,
            ry: 5
        },
        foreignObject: {
            width: 'calc(w-20)',
            height: 'calc(h-20)',
            x: 10,
            y: 10
        }
    },
}, {
    // The /* xml */ comment is optional.
    // It is used to tell the IDE that the markup is XML.
    markup: joint.util.svg/* xml */`
        &lt;rect @selector="body"/&gt;
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div @selector="content"
                    xmlns="http://www.w3.org/1999/xhtml"
                    style="font-family: sans-serif; font-size: 16px; color: white;"
            &gt;
                &lt;p @selector="textContent"
                    style="margin: 0; padding: 5px"
                &gt;
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <h3>A more interactive example</h3>

        <p>
            One typical method which diagram libraries utilize to allow users work with HTML is to render HTML on top of an underlying element.
            While this approach can be successful, it comes with a lot of additional complexity such as the need to keep dimensions and position 
            of the HTML in sync with the element itself which isn't ideal. It's possible to use this approach with JointJS, and still to this day,
            this is how many diagram libraries provide this functionality, especially if they use
            HTML <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" target="_blank">canvas</a>.
        </p>

        <p>
            As JointJS primarily works with SVG, and SVG was designed to work well with other web standards such as HTML, taking advantage of
            <code>foreignObject</code> can allow users of JointJS create HTML-rich elements while avoiding some of the difficulties of other 
            approaches.
        </p>

        <p>
            Creating a static card-like element was a gentle introduction to working with <code>foreignObject</code>, but if we are being realistic,
            a lot of users will most likely want to work with more interactive elements. A <code>form</code> element is a section which usually 
            contains some of the most interactive controls on the web, so let's try to create a custom element which allows the user to submit some 
            data.
        </p>

        <p>
            In our previous example, we created an SVG <code>rect</code> element alongside our <code>foreignObject</code>. If your shape requires
            other SVG elements, it's possible to add them in the same manner, but it's also not a requirement. You may find that 
            <code>foreignObject</code> is sufficient, and it's the only SVG element you wish to define explicitly. In our <code>form</code>
            example, that's exactly the route we will take, and you can see it demonstrated in the following code example.
        </p>

        <pre><code>const Form = joint.dia.Element.define('example.Form', {
    attrs: {
        foreignObject: {
            width: 'calc(w)',
            height: 'calc(h)'
        }
    }
}, {
    markup: joint.util.svg/* xml */`
        &lt;foreignObject @selector="foreignObject"&gt;
            &lt;div @selector="content"
                xmlns="http://www.w3.org/1999/xhtml"
                style="font-family: sans-serif;"
            &gt;
                &lt;form @selector="formContent" id="form"&gt;
                    &lt;label @selector="label" for="diagramName">Name&gt;/label&gt;
                    &lt;input @selector="diagramName" type="text" id="diagramName" name="diagramName"/&gt;
                    &lt;input @selector="submit" type="submit" value="submit"/&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/foreignObject&gt;
    `
});
</code></pre>

        <p>
            As the default styles for our <code>form</code> are a little boring, we will also add the following CSS just to make our elements a 
            little more presentable. It's also possible to add CSS via an SVG 
            <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/style" target="_blank"><code>style</code></a> element, or inline 
            styles via the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/style" target="_blank">style</a> attribute 
            if you prefer, but as we are adding a substantial amount of CSS, we will use a separate stylesheet.
        </p>

        <pre><code>g[data-type="example.Form"] {
    filter: drop-shadow(0.35rem 0.35rem 0.4rem rgba(0, 0, 0, 0.5));
}

form {
    font-size: 16px;
    margin: 1.2rem;
}

label {
    color: darkslategray;
    display: inline-block;
    font-size: 12px;
    margin-bottom: 0.4rem;
}

input {
    box-sizing: border-box;
    font-size: inherit;
    margin-bottom: 0.8rem;
    width: 100%;
}
</code></pre>

        <div class="paper" id="paper-foreign-object-prevent-default"></div>
        <p>JointJS source code: <a href="js/foreign-object-part-2.js" target="_blank">foreign-object-part-2.js</a></p>


        <p>
            The joy of working with <code>foreignObject</code> in our shapes is that we still get to take advantage of native web functionality.
            When using a <code>form</code>, you might be used to programmatically associating a <code>label</code> with an <code>input</code> 
            by providing an <code>'id'</code>
            attribute to the <code>input</code>, and a <code>'for'</code> attribute to the <code>label</code> which has the same value. This has
            a number of advantages such as screen readers reading the label when the associated input is focused, and also that the focus is 
            passed to the input when the associated label is clicked.
        </p>

        <p>
            On the other hand, when working with JointJS, you will have to make decisions about how some HTML elements lose focus. If a user clicks 
            on a blank area, you may wish that an <code>input</code> lose focus which is behavior we are familiar with from HTML. In order to mimic 
            this behaviour in JointJS, we can create an event to remove focus when the user clicks on a blank <code>paper</code> area, or even on
            any JointJS element.
        </p>

        <pre><code>paper.on('blank:pointerdown cell:pointerdown', () => {
    document.activeElement.blur();
});
</code></pre>

        <p>
            Earlier, we mentioned that we wanted to prevent the <code>paper</code> from handling browser UI events related to a paragraph, and we
            did this via the <code>paper</code> <code>guard</code> option. You may be asking yourself, why don't we need to use the <code>guard</code> 
            option for this example?
        </p>

        <p>
            The simple explanation is that JointJS prevents its own default interactions when working with HTML form controls. That means for example, 
            if you try to drag an <code>input</code>, the element doesn't move as a whole, but it selects the text inside the input. The elements 
            where JointJS prevents the default interaction are as follows:
        </p>

        <ul>
            <li><code>textarea</code></li>
            <li><code>input</code></li>
            <li><code>button</code></li>
            <li><code>select</code></li>
            <li><code>option</code></li>
        </ul>

        <p>
            In the example above, we created a paper event with the aim of managing focus. One detail you may not have noticed is that the 
            <code>button</code> text is actually contained within a <code>span</code> element. If we had not applied the <code>paper</code> event, 
            and the <code>input</code> was in focus, clicking on the <code>span</code> element won't actually cause the input to lose focus. However, 
            clicking on the <code>button</code> itself will make the <code>input</code> lose focus, as <code>button</code> is one of the 
            elements where JointJS prevents the default interaction.
        </p>

        <p>
            If we wanted the <code>input</code> to lose focus when a user clicks on the <code>span</code> element, we can take advantage of the
            <code>guard</code> option as follows <code>guard: (evt) => ['SPAN'].includes(evt.target.tagName)</code>. Although, including the 
            <code>guard</code> option to manage focus in this instance would be superfluous if the <code>paper</code> event is already applied.
        </p>

        <p>
            One of the final items you may wish to take are of when using a <code>form</code> in JointJS is to prevent the default browser behaviour 
            when submitting user data. In order to achieve this we will create a custom 
            <a href="/docs/jointjs#dia.CellView.custom" target="_blank"><code>CellView</code></a> for our element. It will contain an events hash 
            which specifies a DOM event that will be bound to a method on the view. The <i>key</i> is made up of the event name plus a CSS selector, 
            and the <i>value</i> is a method on our custom view.
        </p>

        <p>
            In the following example, we specify the event name <code>'submit'</code>, plus our CSS element selector <code>'form'</code>, and lastly 
            the name of our method <code>'onSubmit'</code>. We can prevent that browser refresh by using <code>evt.preventDefault()</code>, and clear 
            the value of the HTML input value afterwards if we wish to do so.
        </p>

        <pre><code>joint.shapes.example.FormView = joint.dia.ElementView.extend({

    events: {
        'submit form': 'onSubmit'
    },

    onSubmit: function(evt) {
        evt.preventDefault();
        evt.target.children.diagramName.value = ''; // remove input value after submit
    },

});
</code></pre>

        <h4>Props, a special attribute</h4>

        <p>
            The last point which we would like to cover when discussing HTML form controls is the special 
            <a href="/docs/jointjs##dia.attributes.props" target="_blank"><code>props</code></a> attribute. When creating HTML elements, it's 
            possible to define various attributes to initialize certain DOM properties. In some cases such as <code>'id'</code>, 
            this is a one-to-one relationship, while in others such as <code>'value'</code>, the attribute doesn't reflect the property, and it
            serves more like an initial and current state. 
        </p>

        <p>
            When working with JointJS, it wouldn't make sense that users can only set an initial <code>'value'</code> attribute for an 
            <code>input</code>, and then have to access DOM elements themselves to update the <code>'value'</code> property. If using 
            <code>foreignObject</code>, users should be able to set the <code>'value'</code> at any time they want through the model. It's for this
            exact reason that we created the special <code>props</code> attribute, and it can be utilized as follows:
        </p>

        <pre><code>// Example markup
&lt;input @selector="example" type="text" value="initial" /&gt;

// Set the input value on the model
element.attr('example/props/value', 'current');


// For illustration purposes - not required to access DOM elements to set values
const input = document.querySelector('input');

// Expected values
console.log(input.value); // current
console.log(input.defaultValue); // initial
console.log(input.getAttribute('value')); // initial
</code></pre>

        <p>
            The supported properties when using <code>props</code> are:
        </p>

        <ul>
            <li><code>checked</code></li>
            <li><code>selected</code></li>
            <li><code>disabled</code></li>
            <li><code>readOnly</code></li>
            <li><code>contentEditable</code></li>
            <li><code>value</code></li>
            <li><code>indeterminate</code></li>
            <li><code>multiple</code></li>
        </ul>


        <!-- 
            propsPR example
         -->

        <!-- 
            Show example with CSS layouts, 3 elements (maybe in grid)
         -->

        <!-- <div class="paper" id="paper-foreign-object"></div> -->

        <!-- <p>
            preventDefault paper option
        </p> -->

        

        <!-- TODO
            - how to use
            - test specificity, inline vs stylesheet
            - syntax with curly brackets?
        -->

        <!-- <h3>CSS Styles</h3> -->

        <h3>Caveats!!!</h3>

        <p>
            While all that we have covered so far is great for users of JointJS, even in this day and age, it's not without some caveats.
            Firstly, we will cover some relatively minor caveats regarding syntax, and afterwards we'll look at some browser related quirks.
        </p>


        <h4>Syntax</h4>


        <p><i>Boolean Attributes</i></p>

        <p>
            Boolean attributes are those data types where the presence or absence of the attribute represents its <i>truthy</i> or <i>falsy</i>
            value respectively. Some common examples are <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required" target="_blank"> 
            <code>required</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled" target="_blank"><code>disabled</code></a>, 
            and <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly" target="_blank"><code>readonly</code></a>.
        </p>

        <p>
            Usually, boolean attributes can be utilized in 3 different ways, you can omit the value, use an empty string, or set the value as a
            case-insensitive match for the attribute's name. In our case, we cannot omit the value, so we must use the 2nd or 3rd option. This is 
            demonstrated in the following example which uses the <code>required</code> attribute.
        </p>

        <pre><code>// omitted value will throw error ❌
&lt;input @selector="name" type="text" id="name" name="name" required /&gt;

// use an empty string
&lt;input @selector="name" type="text" id="name" name="name" required="" /&gt;

// use a case-insensitive match for the attribute's name
&lt;input @selector="name" type="text" id="name" name="name" required="required" /&gt;
</code></pre>

        <p><i>Closing Tags</i></p>

        <p>
            In the past, developers traditionally used start and end tags for HTML elements. If we wanted some text on the page, we might 
            create the following paragraph element <code>&lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;</code>. With the advent 
            of HTML5, it's not strictly necessary to close certain elements which are considered 
            <a href="https://developer.mozilla.org/en-US/docs/Glossary/Void_element" target="_blank">void</a>, i.e., elements which can't have 
            child nodes.
        </p>

        <p>
            In HTML, it's possible to write a line-break element as <code>&lt;br&gt;</code> or <code>&lt;br /&gt;</code>. The trailing slash
            in the tag has no meaning, and browsers simply ignore it. However, in XML, XHTML, and SVG, self closing tags are required in void elements, 
            so a trailing slash is necessary. When working with tagged templates in JointJS, you must use a trailing slash. This can be 
            observed in the following example:
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="font-family: sans-serif;"
    &gt;
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
        &lt;br&gt; // line-break element without trailing slash will throw an error ❌
        &lt;p&gt;Lorem ipsum dolor sit amet consectetur.&lt;/p&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>

        <p><i>HTML Entities</i></p>

        <p>
            HTML Entities are used in place of some characters that are reserved depending on the language. For example,
            the greater than (>) or less than (<) sign cannot be used in HTML as it would cause a conflict with tags.
            This is also one area to be careful with when using tagged templates. You must use the entity number rather than
            the entity name. Entity names are the ones which use the # symbol. That means using <code>&amp;#169;</code> 
            is preferable over <code>&amp;copy;</code>.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content" xmlns="http://www.w3.org/1999/xhtml"&gt;
        &amp;copy; // copy HTML entity name will throw an error ❌
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>
        
        <!-- TODO
            - foreignObject export in JointJS+
         -->


        <h4>Browser Related Quirks</h4>

        <p>
            At the beginning of this tutorial, we mentioned how <code>foreignObject</code> is fully supported in all browsers.
            Unfortunately, that doesn't mean some inconsistencies exist, or that some unexpected behaviour might occur. 
        </p>

        <p>
            Our experience with both Chrome and Firefox has been very positive, but we have ran into some quirks when using Safari. 
            In this section, we will cover some issues we discovered, and some related 
            <a href="https://bugs.webkit.org/query.cgi" target="_blank">webkit</a> bugs, but this also isn't an exhaustive list, so you 
            might run into an issue with Safari that isn't mentioned here.
        </p>

        <p>
            The first issue arose when we tried to add a HTML5 <code>video</code> element to our shape. While this went as expected
            with Chrome and Firefox, the video seemed to be rendered in an incorrect position on Safari. After searching for a solution,
            we stumbled on the following <a href="https://bugs.webkit.org/show_bug.cgi?id=23113" target="_blank">webkit bug</a>.
        </p>

        <p>
            Upon reading, we couldn't help but notice others suggesting that properties like <code>opacity</code>, or <code>transform</code>
            were also causing issues for Safari users, so we added some styles to our elements, and sure enough, we saw similar results.
            Elements which had both <code>opacity</code> or <code>transform</code> applied were also in the incorrect position.
        </p>

        <p>
            Naturally, we also search the same bug report for any potential solutions, and found reporting that adding a style of
            <code>'position: fixed'</code> to the outermost <code>div</code> element fixed some of the issued that people had. Once again,
            the information proved to be helpful, and the elements seemed to be positioned correctly again.
        </p>

        <p>
            Upon further inspection, we did realize, we still had one major issue with the video. After dragging our JointJS shape, the video
            was still rendered in the incorrect position after changing position which was disappointing. The silver lining is that the
            <code>opacity</code> and <code>transform</code> applied to our <code>label</code> and <code>input</code> was working correctly.
        </p>

        <pre><code>&lt;foreignObject @selector="foreignObject"&gt;
    &lt;div @selector="content"
        xmlns="http://www.w3.org/1999/xhtml"
        style="position: fixed; font-family: sans-serif;"
    &gt;
        &lt;span style="opacity: 0.5">First Name&lt;/span&gt;
        &lt;input @selector="firstname" type="text" style="transform: translateX(10px); width: 100%;"/&gt;
        &lt;span>Last Name&lt;/span>
        &lt;input @selector="lastname" type="text" style="width: 100%;"/&gt;
        &lt;span>Video&lt;/span>
        &lt;video @selector="video" controls="controls" width="200"&gt;
            &lt;source src="path_to_video.mp4" type="video/mp4" /&gt;
        &lt;/video&gt;
    &lt;/div&gt;
&lt;/foreignObject&gt;
</code></pre>

        <p>
            It's unfortunate that Safari still lags behind other modern browsers in relation to <code>foreignObject</code>, but there are also reasons to be positive.
            One reason to have a brighter outlook is that the issues we had here are currently being worked on according to this 
            <a href="https://bugs.webkit.org/show_bug.cgi?id=90738" target="_blank">bug</a> report, so hopefully in the not too distant future the majority of these issues
            will cease to exist.`
        </p>


        <!-- TODO
            Section on Caveats
            - safari issues with foreignObject, link to some bugs
        -->

        <!-- TODO
            - Workarounds for video - position: fixed;
            https://stackoverflow.com/questions/61895287/wrong-position-of-video-element-inside-svg-foreignobject-on-safari
            https://github.com/bkrem/react-d3-tree/issues/284
            - May be needed to remove use of opacity, elements with positioning, opacity, or transform seem to be affected.
            https://bugs.webkit.org/show_bug.cgi?id=23113
            - Select element even outside of foreignObject does not fire click event, pointerup.
            https://bugs.webkit.org/show_bug.cgi?id=239964
            https://bugs.webkit.org/show_bug.cgi?id=197612
         -->

         <!-- 
            when you open the <select> in:
            Chrome: it triggers pointerdown, pointerup, pointerclick as soon as its open
            Firefox: it triggers pointerdown on open and pointerup (and pointerclick only if you didn’t move) on close. But! If you open and then close by clickc somewhere else on the page, no other event is triggered.
            Safari: it triggers pointerdown on open. that’s it.
            There is another bug in Safari.
            <select multiple=“true”> does not allow you to select option with mouse (it works with keyboard)
          -->

          <!-- 
            position: static + overflow issue
           -->
        <h3>Conclusion</h3>

        <p>
            We believe <code>foreignObject</code> support is a big step forward for JointJS. It will allow our users to create 
            even more innovative and interactive diagramming solutions, and we can't wait to see what they create.
        </p>

        <script src="../node_modules/prismjs/prism.js"></script>

        <script src="js/foreign-object.js"></script>
        <script src="js/foreign-object-part-2.js"></script>
    </body>
</html>

