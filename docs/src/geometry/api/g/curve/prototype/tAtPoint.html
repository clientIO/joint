<pre class="docs-method-signature"><code>curve.tAtPoint(point [, opt])</code></pre>
<p>Return the <code>t</code> value of provided <code>point</code>.</p>

<p>If it is detected that <code>point</code> does not lie on the curve, <code>null</code> is returned instead.</p>

<p>The curve is first subdivided, according to <code>opt.precision + 1</code> (refer to <code>curve.length()</code> <a href="geometry.html#g.curve.prototype.length">documentation</a> for more information about precision and curve flattening). Then, one subdivision is identified whose endpoints are the closest to <code>point</code>. A binary search is then performed on that subdivision, until a curve is found whose endpoint lies within <code>opt.precision + 1</code> away from <code>p</code>. The <code>t</code> value of that endpoint is returned by the function (refer to <code>curve.pointAtLength()</code> <a href="geometry.html#g.curve.prototype.pointAtLength">documentation</a> for more information).</p>

<p>The default value for <code>opt.precision</code> is 2; this corresponds to maximum observed error of 1%.</p>

<p>The <code>opt.subdivisions</code> property may be specified, directly providing an array of pre-computed curve subdivisions from which to calculate curve length. Use the <code>curve.getSubdivisions()</code> <a href="geometry.html#g.curve.prototype.getSubdivisions">function</a> to obtain an array of curve subdivisions.</p>

<p>The <code>opt.precision</code> property is still necessary, however; it determines the precision of the point search algorithm. Beware that <code>opt.precision</code> will not match the precision of <code>opt.subdivisions</code> unless the subdivisions were created with precision of <code>opt.precision + 1</code>!</p>
