<pre class="docs-method-signature"><code>curve.divideAtLength(length [, opt])</code></pre>
<p>Divide the curve into two curves at the point that lies <code>length</code> away from the beginning of the curve.</p>

<p>Returns an array with two new curves without modifying the original curve. If negative <code>length</code> is provided, the algorithm starts looking from the end of the curve. If <code>length</code> is higher than curve length, the curve is divided at the closest endpoint instead.</p>

<p>The curve is first subdivided, according to <code>opt.precision</code> (refer to <code>curve.length()</code> <a href="geometry.html#g.Curve.prototype.length">documentation</a> for more information about precision and curve flattening). Then, one subdivision is identified which contains the point at <code>length</code>. A binary search is then performed on that subdivision, until a curve is found whose endpoint lies within <code>opt.precision</code> away from <code>length</code>. That endpoint is used by the function to divide the curve.</p>

<p>The default value for <code>opt.precision</code> is 3; this corresponds to maximum observed error of 0.1%.</p>

<p>As a rule of thumb, increasing precision by 1 doubles the number of operations needed to find the point to be returned (this is on top of the cost of curve subdivision); exact numbers vary for every individual curve, however.</p>

<p>The <code>opt.subdivisions</code> property may be specified, directly providing an array of pre-computed curve subdivisions from which to calculate curve length. Use the <code>curve.getSubdivisions()</code> <a href="geometry.html#g.Curve.prototype.getSubdivisions">function</a> to obtain an array of curve subdivisions. The <code>opt.precision</code> property is still necessary, however; it determines the precision of the point search algorithm.</p>
