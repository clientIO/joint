<pre class="docs-method-signature"><code>graph.bfs(element, iteratee [, opt])</code></pre>
<p>Traverse the graph using the <a target="_blank" href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search algorithm</a> starting at <code>element</code> (note the element itself will be visited too). <code>iteratee</code> is a function of the form <code>function(element, distance) {}</code> that will be called with the currently visited element and distance of that element from the root element of the search (the <code>element</code> passed to <code>bfs()</code>). If <code>iteratee</code> explicitely returns <code>false</code>, the search stops.</p>
<p>The following image shows the order in which elements are traversed in the graph:</p>
<p><img width="200" alt="graph BFS algorithm" title="graph BFS algorithm" src="images/joint.dia.Graph.bfs.png"></p>
<p>Note that the <code>bfs()</code> algorithm is not only capable of traversing tree graphs but it can traverse any directed graph too.</p>
<p>It is smart enough not to traverse an element that was already visited.</p>
<p>If <code>opt.inbound</code> is <code>true</code>, reverse the search direction (it's like reversing all the link directions, i.e. swaping their <code>source</code> and <code>target</code>).</p>
<p>If <code>opt.outbound</code> is <code>true</code>, search follows the link directions. Calling <code>bfs()</code> with <code>opt.outbound</code> set to <code>true</code> is the most common case (graph is traversed following the direction of links).</p>
<p>If none of <code>opt.inbound</code> and <code>opt.outbound</code> are used or both options are set to <code>true</code>, the graph is traversed in both directions (very rare use case).</p>
<p>If <code>opt.deep</code> is <code>true</code>, the traversal takes into account embedded elements too. This option has the usual meaning as in other methods were <code>deep</code> option is used. For example, in a hierarchy A (top level element), A1 (embedded in A), B (top level element), where A is not directly connected to B but its embedded element is (there is a link from A1 ----&gt; B), bfs(A)would not visit B but bfs(A, function() {}, { deep: true }) would.</p>
